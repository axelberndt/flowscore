{"version":3,"file":"VirtualScroller.js","names":["VirtualScrollerConstructor","hasTbodyStyles","addTbodyStyles","LAYOUT_REASON","log","warn","VirtualScroller","getItemsContainerElement","items","options","_isActive","Error","scrollableContainerResizeHandler","stop","scroll","listTopOffsetWatcher","isStarted","cancelLayoutTimer","hasToBeStarted","onUpdateShownItemIndexes","reason","MANUAL","_onRender","getState","previousState","call","isRestart","waitingForRender","_usesCustomStateStorage","useDefaultStateStorage","_render","listHeightMeasurement","reset","_isResizing","undefined","_isSettingNewItems","tbody","stateUpdate","_afterRenderStateUpdateThatWasStopped","verticalSpacing","verticalSpacingStateUpdate","measureItemHeightsAndSpacing","start","scrollableContainerWidth","scrollableContainer","getWidth","newWidth","prevWidth","onContainerResize","columnsCount","getActualColumnsCount","columnsCountFromState","STARTED","i","itemTopOffsetInList","layout","getItemTopOffset","getListTopOffsetInsideScrollableContainer","onItemHeightDidChange","_onItemHeightDidChange","newItemState","_setItemState","setItemState","newItems","_setItems"],"sources":["../source/VirtualScroller.js"],"sourcesContent":["import VirtualScrollerConstructor from './VirtualScroller.constructor.js'\nimport { hasTbodyStyles, addTbodyStyles } from './DOM/tbody.js'\nimport { LAYOUT_REASON } from './Layout.js'\nimport log, { warn } from './utility/debug.js'\n\nexport default class VirtualScroller {\n\t/**\n\t * @param  {function} getItemsContainerElement — Returns the container DOM `Element`.\n\t * @param  {any[]} items — The list of items.\n\t * @param  {Object} [options] — See README.md.\n\t * @return {VirtualScroller}\n\t */\n\tconstructor(\n\t\tgetItemsContainerElement,\n\t\titems,\n\t\toptions = {}\n\t) {\n\t\tVirtualScrollerConstructor.call(\n\t\t\tthis,\n\t\t\tgetItemsContainerElement,\n\t\t\titems,\n\t\t\toptions\n\t\t)\n\t}\n\n\t/**\n\t * Should be invoked after a \"container\" DOM Element is mounted (inserted into the DOM tree).\n\t */\n\tstart() {\n\t\tif (this._isActive) {\n\t\t\tthrow new Error('[virtual-scroller] `VirtualScroller` has already been started')\n\t\t}\n\n\t\t// If has been stopped previously.\n\t\tconst isRestart = this._isActive === false\n\n\t\tif (!isRestart) {\n\t\t\tthis.waitingForRender = true\n\n\t\t\t// If no custom state storage has been configured, use the default one.\n\t\t\t// Also sets the initial state.\n\t\t\tif (!this._usesCustomStateStorage) {\n\t\t\t\tthis.useDefaultStateStorage()\n\t\t\t}\n\t\t\t// If `render()` function parameter was passed,\n\t\t\t// perform an initial render.\n\t\t\tif (this._render) {\n\t\t\t\tthis._render(this.getState())\n\t\t\t}\n\t\t}\n\n\t\tif (isRestart) {\n\t\t\tlog('~ Start (restart) ~')\n\t\t} else {\n\t\t\tlog('~ Start ~')\n\t\t}\n\n\t\t// `this._isActive = true` should be placed somewhere at the start of this function.\n\t\tthis._isActive = true\n\n\t\t// Reset `ListHeightMeasurement` just in case it has some \"leftover\" state.\n\t\tthis.listHeightMeasurement.reset()\n\n\t\t// Reset `_isResizing` flag just in case it has some \"leftover\" value.\n\t\tthis._isResizing = undefined\n\n\t\t// Reset `_isSettingNewItems` flag just in case it has some \"leftover\" value.\n\t\tthis._isSettingNewItems = undefined\n\n\t\t// Work around `<tbody/>` not being able to have `padding`.\n\t\t// https://gitlab.com/catamphetamine/virtual-scroller/-/issues/1\n\t\tif (this.tbody) {\n\t\t\tif (!hasTbodyStyles(this.getItemsContainerElement())) {\n\t\t\t\taddTbodyStyles(this.getItemsContainerElement())\n\t\t\t}\n\t\t}\n\n\t\t// If there was a pending \"after render\" state update that didn't get applied\n\t\t// because the `VirtualScroller` got stopped, then apply that pending \"after render\"\n\t\t// state update now. Such state update could include properties like:\n\t\t// * A `verticalSpacing` that has been measured in `onRender()`.\n\t\t// * A cleaned-up `beforeResize` object that was cleaned-up in `onRender()`.\n\t\tlet stateUpdate = this._afterRenderStateUpdateThatWasStopped\n\t\tthis._afterRenderStateUpdateThatWasStopped = undefined\n\n\t\t// Reset `this.verticalSpacing` so that it re-measures it in cases when\n\t\t// the `VirtualScroller` was previously stopped and is now being restarted.\n\t\t// The rationale is that a previously captured inter-item vertical spacing\n\t\t// can't be \"trusted\" in a sense that the user might have resized the window\n\t\t// after the previous `state` has been snapshotted.\n\t\t// If the user has resized the window, then changing window width might have\n\t\t// activated different CSS `@media()` \"queries\" resulting in a potentially different\n\t\t// vertical spacing after the restart.\n\t\t// If it's not a restart then `this.verticalSpacing` is `undefined` anyway.\n\t\tthis.verticalSpacing = undefined\n\n\t\tconst verticalSpacingStateUpdate = this.measureItemHeightsAndSpacing()\n\t\tif (verticalSpacingStateUpdate) {\n\t\t\tstateUpdate = {\n\t\t\t\t...stateUpdate,\n\t\t\t\t...verticalSpacingStateUpdate\n\t\t\t}\n\t\t}\n\n\t\tthis.scrollableContainerResizeHandler.start()\n\t\tthis.scroll.start()\n\n\t\t// If `scrollableContainerWidth` hasn't been measured yet,\n\t\t// measure it and write it to state.\n\t\tif (this.getState().scrollableContainerWidth === undefined) {\n\t\t\tconst scrollableContainerWidth = this.scrollableContainer.getWidth()\n\t\t\tstateUpdate = {\n\t\t\t\t...stateUpdate,\n\t\t\t\tscrollableContainerWidth\n\t\t\t}\n\t\t} else {\n\t\t\t// Reset layout:\n\t\t\t// * If the scrollable container width has changed while stopped.\n\t\t\t// * If the restored state was calculated for another scrollable container width.\n\t\t\tconst newWidth = this.scrollableContainer.getWidth()\n\t\t\tconst prevWidth = this.getState().scrollableContainerWidth\n\t\t\tif (newWidth !== prevWidth) {\n\t\t\t\tlog('~ Scrollable container width changed from', prevWidth, 'to', newWidth, '~')\n\t\t\t\t// The pending state update (if present) won't be applied in this case.\n\t\t\t\t// That's ok because such state update could currently only originate in\n\t\t\t\t// `this.onContainerResize()` function. Therefore, alling `this.onContainerResize()` again\n\t\t\t\t// would rewrite all those `stateUpdate` properties anyway, so they're not passed.\n\t\t\t\treturn this.onContainerResize()\n\t\t\t}\n\t\t}\n\n\t\t// If the `VirtualScroller` uses custom (external) state storage, then\n\t\t// check if the columns count has changed between calling `.getInitialState()`\n\t\t// and `.start()`. If it has, perform a re-layout \"from scratch\".\n\t\tif (this._usesCustomStateStorage) {\n\t\t\tconst columnsCount = this.getActualColumnsCount()\n\t\t\tconst columnsCountFromState = this.getState().columnsCount || 1\n\t\t\tif (columnsCount !== columnsCountFromState) {\n\t\t\t\treturn this.onContainerResize()\n\t\t\t}\n\t\t}\n\n\t\t// Re-calculate layout and re-render the list.\n\t\t// Do that even if when an initial `state` parameter, containing layout values,\n\t\t// has been passed. The reason is that the `state` parameter can't be \"trusted\"\n\t\t// in a way that it could have been snapshotted for another window width and\n\t\t// the user might have resized their window since then.\n\t\tthis.onUpdateShownItemIndexes({ reason: LAYOUT_REASON.STARTED, stateUpdate })\n\t}\n\n\t// Could be passed as a \"callback\" parameter, so bind it to `this`.\n\tstop = () => {\n\t\tif (!this._isActive) {\n\t\t\tthrow new Error('[virtual-scroller] Can\\'t stop a `VirtualScroller` that hasn\\'t been started')\n\t\t}\n\n\t\tthis._isActive = false\n\n\t\tlog('~ Stop ~')\n\n\t\tthis.scrollableContainerResizeHandler.stop()\n\t\tthis.scroll.stop()\n\n\t\t// Stop `ListTopOffsetWatcher` if it has been started.\n\t\t// There seems to be no need to restart `ListTopOffsetWatcher`.\n\t\t// It's mainly a hacky workaround for development mode anyway.\n\t\tif (this.listTopOffsetWatcher && this.listTopOffsetWatcher.isStarted()) {\n\t\t\tthis.listTopOffsetWatcher.stop()\n\t\t}\n\n\t\t// Cancel any scheduled layout.\n\t\tthis.cancelLayoutTimer({})\n\t}\n\n\thasToBeStarted() {\n\t\tif (!this._isActive) {\n\t\t\tthrow new Error('[virtual-scroller] `VirtualScroller` hasn\\'t been started')\n\t\t}\n\t}\n\n\t// Bind it to `this` because this function could hypothetically be passed\n\t// as a \"callback\" parameter.\n\tupdateLayout = () => {\n\t\tthis.hasToBeStarted()\n\t\tthis.onUpdateShownItemIndexes({ reason: LAYOUT_REASON.MANUAL })\n\t}\n\n\t// Bind the function to `this` so that it could be passed as a callback\n\t// in a random application's code.\n\tonRender = () => {\n\t\tthis._onRender(this.getState(), this.previousState)\n\t}\n\n\t/**\n\t * Returns the items's top offset relative to the scrollable container's top edge.\n\t * @param {number} i — Item index\n\t * @return {[number]} Returns the item's scroll Y position. Returns `undefined` if any of the previous items haven't been rendered yet.\n\t */\n\tgetItemScrollPosition(i) {\n\t\tconst itemTopOffsetInList = this.layout.getItemTopOffset(i)\n\t\tif (itemTopOffsetInList === undefined) {\n\t\t\treturn\n\t\t}\n\t\treturn this.getListTopOffsetInsideScrollableContainer() + itemTopOffsetInList\n\t}\n\n\t/**\n\t * @deprecated\n\t * `.onItemHeightChange()` has been renamed to `.onItemHeightDidChange()`.\n\t */\n\tonItemHeightChange(i) {\n\t\twarn('`.onItemHeightChange(i)` method was renamed to `.onItemHeightDidChange(i)`')\n\t\tthis.onItemHeightDidChange(i)\n\t}\n\n\t/**\n\t * Forces a re-measure of an item's height.\n\t * @param  {number} i — Item index\n\t */\n\tonItemHeightDidChange(i) {\n\t\t// See the comments in the `setItemState()` function below for the rationale\n\t\t// on why the `hasToBeStarted()` check was commented out.\n\t\t// this.hasToBeStarted()\n\t\tthis._onItemHeightDidChange(i)\n\t}\n\n\t/**\n\t * Updates an item's state in `state.itemStates[]`.\n\t * @param  {number} i — Item index\n\t * @param  {any} i — Item's new state\n\t */\n\tsetItemState(i, newItemState) {\n\t\t// There is an issue in React 18.2.0 when `useInsertionEffect()` doesn't run twice\n\t\t// on mount unlike `useLayoutEffect()` in \"strict\" mode. That causes a bug in a React\n\t\t// implementation of the `virtual-scroller`.\n\t\t// https://gitlab.com/catamphetamine/virtual-scroller/-/issues/33\n\t\t// https://github.com/facebook/react/issues/26320\n\t\t// A workaround for that bug is ignoring the second-initial run of the effects at mount.\n\t\t//\n\t\t// But in that case, if an `ItemComponent` calls `setItemState()` in `useLayoutEffect()`,\n\t\t// it could result in a bug.\n\t\t//\n\t\t// Consider a type of `useLayoutEffect()` that skips the initial mount:\n\t\t// `useLayoutEffectSkipInitialMount()`.\n\t\t// Suppose that effect is written in such a way that it only skips the first call of itself.\n\t\t// In that case, if React is run in \"strict\" mode, the effect will no longer work as expected\n\t\t// and it won't actually skip the initial mount and will be executed during the second initial run.\n\t\t// But the `VirtualScroller` itself has already implemented a workaround that prevents\n\t\t// its hooks from running twice on mount. This means that `useVirtualScrollerStartStop()`\n\t\t// of the React component would have already stopped the `VirtualScroller` by the time\n\t\t// `ItemComponent`'s incorrectly-behaving `useLayoutEffectSkipInitialMount()` effect is run,\n\t\t// resulting in an error: \"`VirtualScroller` hasn't been started\".\n\t\t//\n\t\t// The log when not in \"strict\" mode would be:\n\t\t//\n\t\t// * `useLayoutEffect()` is run in `ItemComponent` — skips the initial run.\n\t\t// * `useLayoutEffect()` is run in `useVirtualScrollerStartStop()`. It starts the `VirtualScroller`.\n\t\t// * Some dependency property gets updated inside `ItemComponent`.\n\t\t// * `useLayoutEffect()` is run in `ItemComponent` — no longer skips. Calls `setItemState()`.\n\t\t// * The `VirtualScroller` is started so it handles `setState()` correctly.\n\t\t//\n\t\t// The log when in \"strict\" mode would be:\n\t\t//\n\t\t// * `useLayoutEffect()` is run in `ItemComponent` — skips the initial run.\n\t\t// * `useLayoutEffect()` is run in `useVirtualScrollerStartStop()`. It starts the `VirtualScroller`.\n\t\t// * `useLayoutEffect()` is unmounted in `useVirtualScrollerStartStop()`. It stops the `VirtualScroller`.\n\t\t// * `useLayoutEffect()` is unmounted in `ItemComponent` — does nothing.\n\t\t// * `useLayoutEffect()` is run the second time in `ItemComponent` — no longer skips. Calls `setItemState()`.\n\t\t// * The `VirtualScroller` is stopped so it throws an error: \"`VirtualScroller` hasn't been started\".\n\t\t//\n\t\t// For that reason, the requirement of the `VirtualScroller` to be started was commented out.\n\t\t// Commenting it out wouldn't result in any potential bugs because the code would work correctly\n\t\t// in both cases.\n\t\t// this.hasToBeStarted()\n\t\tthis._setItemState(i, newItemState)\n\t}\n\n\t// (deprecated)\n\t// Use `.setItemState()` method name instead.\n\tonItemStateChange(i, newItemState) {\n\t\tthis.setItemState(i, newItemState)\n\t}\n\n\t/**\n\t * Updates `items`. For example, can prepend or append new items to the list.\n\t * @param  {any[]} newItems\n\t * @param {boolean} [options.preserveScrollPositionOnPrependItems] — Set to `true` to enable \"restore scroll position after prepending items\" feature (could be useful when implementing \"Show previous items\" button).\n\t */\n\tsetItems(newItems, options = {}) {\n\t\tthis.hasToBeStarted()\n\t\treturn this._setItems(newItems, options)\n\t}\n}"],"mappings":";;;;;;;;;;;;AAAA,OAAOA,0BAAP,MAAuC,kCAAvC;AACA,SAASC,cAAT,EAAyBC,cAAzB,QAA+C,gBAA/C;AACA,SAASC,aAAT,QAA8B,aAA9B;AACA,OAAOC,GAAP,IAAcC,IAAd,QAA0B,oBAA1B;;IAEqBC,e;EACpB;AACD;AACA;AACA;AACA;AACA;EACC,yBACCC,wBADD,EAECC,KAFD,EAIE;IAAA;;IAAA,IADDC,OACC,uEADS,EACT;;IAAA;;IAAA,8BAuIK,YAAM;MACZ,IAAI,CAAC,KAAI,CAACC,SAAV,EAAqB;QACpB,MAAM,IAAIC,KAAJ,CAAU,8EAAV,CAAN;MACA;;MAED,KAAI,CAACD,SAAL,GAAiB,KAAjB;MAEAN,GAAG,CAAC,UAAD,CAAH;;MAEA,KAAI,CAACQ,gCAAL,CAAsCC,IAAtC;;MACA,KAAI,CAACC,MAAL,CAAYD,IAAZ,GAVY,CAYZ;MACA;MACA;;;MACA,IAAI,KAAI,CAACE,oBAAL,IAA6B,KAAI,CAACA,oBAAL,CAA0BC,SAA1B,EAAjC,EAAwE;QACvE,KAAI,CAACD,oBAAL,CAA0BF,IAA1B;MACA,CAjBW,CAmBZ;;;MACA,KAAI,CAACI,iBAAL,CAAuB,EAAvB;IACA,CA5JC;;IAAA,sCAsKa,YAAM;MACpB,KAAI,CAACC,cAAL;;MACA,KAAI,CAACC,wBAAL,CAA8B;QAAEC,MAAM,EAAEjB,aAAa,CAACkB;MAAxB,CAA9B;IACA,CAzKC;;IAAA,kCA6KS,YAAM;MAChB,KAAI,CAACC,SAAL,CAAe,KAAI,CAACC,QAAL,EAAf,EAAgC,KAAI,CAACC,aAArC;IACA,CA/KC;;IACDxB,0BAA0B,CAACyB,IAA3B,CACC,IADD,EAEClB,wBAFD,EAGCC,KAHD,EAICC,OAJD;EAMA;EAED;AACD;AACA;;;;;WACC,iBAAQ;MACP,IAAI,KAAKC,SAAT,EAAoB;QACnB,MAAM,IAAIC,KAAJ,CAAU,+DAAV,CAAN;MACA,CAHM,CAKP;;;MACA,IAAMe,SAAS,GAAG,KAAKhB,SAAL,KAAmB,KAArC;;MAEA,IAAI,CAACgB,SAAL,EAAgB;QACf,KAAKC,gBAAL,GAAwB,IAAxB,CADe,CAGf;QACA;;QACA,IAAI,CAAC,KAAKC,uBAAV,EAAmC;UAClC,KAAKC,sBAAL;QACA,CAPc,CAQf;QACA;;;QACA,IAAI,KAAKC,OAAT,EAAkB;UACjB,KAAKA,OAAL,CAAa,KAAKP,QAAL,EAAb;QACA;MACD;;MAED,IAAIG,SAAJ,EAAe;QACdtB,GAAG,CAAC,qBAAD,CAAH;MACA,CAFD,MAEO;QACNA,GAAG,CAAC,WAAD,CAAH;MACA,CA3BM,CA6BP;;;MACA,KAAKM,SAAL,GAAiB,IAAjB,CA9BO,CAgCP;;MACA,KAAKqB,qBAAL,CAA2BC,KAA3B,GAjCO,CAmCP;;MACA,KAAKC,WAAL,GAAmBC,SAAnB,CApCO,CAsCP;;MACA,KAAKC,kBAAL,GAA0BD,SAA1B,CAvCO,CAyCP;MACA;;MACA,IAAI,KAAKE,KAAT,EAAgB;QACf,IAAI,CAACnC,cAAc,CAAC,KAAKM,wBAAL,EAAD,CAAnB,EAAsD;UACrDL,cAAc,CAAC,KAAKK,wBAAL,EAAD,CAAd;QACA;MACD,CA/CM,CAiDP;MACA;MACA;MACA;MACA;;;MACA,IAAI8B,WAAW,GAAG,KAAKC,qCAAvB;MACA,KAAKA,qCAAL,GAA6CJ,SAA7C,CAvDO,CAyDP;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,KAAKK,eAAL,GAAuBL,SAAvB;MAEA,IAAMM,0BAA0B,GAAG,KAAKC,4BAAL,EAAnC;;MACA,IAAID,0BAAJ,EAAgC;QAC/BH,WAAW,mCACPA,WADO,GAEPG,0BAFO,CAAX;MAIA;;MAED,KAAK5B,gCAAL,CAAsC8B,KAAtC;MACA,KAAK5B,MAAL,CAAY4B,KAAZ,GA7EO,CA+EP;MACA;;MACA,IAAI,KAAKnB,QAAL,GAAgBoB,wBAAhB,KAA6CT,SAAjD,EAA4D;QAC3D,IAAMS,wBAAwB,GAAG,KAAKC,mBAAL,CAAyBC,QAAzB,EAAjC;QACAR,WAAW,mCACPA,WADO;UAEVM,wBAAwB,EAAxBA;QAFU,EAAX;MAIA,CAND,MAMO;QACN;QACA;QACA;QACA,IAAMG,QAAQ,GAAG,KAAKF,mBAAL,CAAyBC,QAAzB,EAAjB;QACA,IAAME,SAAS,GAAG,KAAKxB,QAAL,GAAgBoB,wBAAlC;;QACA,IAAIG,QAAQ,KAAKC,SAAjB,EAA4B;UAC3B3C,GAAG,CAAC,2CAAD,EAA8C2C,SAA9C,EAAyD,IAAzD,EAA+DD,QAA/D,EAAyE,GAAzE,CAAH,CAD2B,CAE3B;UACA;UACA;UACA;;UACA,OAAO,KAAKE,iBAAL,EAAP;QACA;MACD,CArGM,CAuGP;MACA;MACA;;;MACA,IAAI,KAAKpB,uBAAT,EAAkC;QACjC,IAAMqB,YAAY,GAAG,KAAKC,qBAAL,EAArB;QACA,IAAMC,qBAAqB,GAAG,KAAK5B,QAAL,GAAgB0B,YAAhB,IAAgC,CAA9D;;QACA,IAAIA,YAAY,KAAKE,qBAArB,EAA4C;UAC3C,OAAO,KAAKH,iBAAL,EAAP;QACA;MACD,CAhHM,CAkHP;MACA;MACA;MACA;MACA;;;MACA,KAAK7B,wBAAL,CAA8B;QAAEC,MAAM,EAAEjB,aAAa,CAACiD,OAAxB;QAAiCf,WAAW,EAAXA;MAAjC,CAA9B;IACA,C,CAED;;;;WAwBA,0BAAiB;MAChB,IAAI,CAAC,KAAK3B,SAAV,EAAqB;QACpB,MAAM,IAAIC,KAAJ,CAAU,2DAAV,CAAN;MACA;IACD,C,CAED;IACA;;;;;IAYA;AACD;AACA;AACA;AACA;IACC,+BAAsB0C,CAAtB,EAAyB;MACxB,IAAMC,mBAAmB,GAAG,KAAKC,MAAL,CAAYC,gBAAZ,CAA6BH,CAA7B,CAA5B;;MACA,IAAIC,mBAAmB,KAAKpB,SAA5B,EAAuC;QACtC;MACA;;MACD,OAAO,KAAKuB,yCAAL,KAAmDH,mBAA1D;IACA;IAED;AACD;AACA;AACA;;;;WACC,4BAAmBD,CAAnB,EAAsB;MACrBhD,IAAI,CAAC,4EAAD,CAAJ;MACA,KAAKqD,qBAAL,CAA2BL,CAA3B;IACA;IAED;AACD;AACA;AACA;;;;WACC,+BAAsBA,CAAtB,EAAyB;MACxB;MACA;MACA;MACA,KAAKM,sBAAL,CAA4BN,CAA5B;IACA;IAED;AACD;AACA;AACA;AACA;;;;WACC,sBAAaA,CAAb,EAAgBO,YAAhB,EAA8B;MAC7B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,KAAKC,aAAL,CAAmBR,CAAnB,EAAsBO,YAAtB;IACA,C,CAED;IACA;;;;WACA,2BAAkBP,CAAlB,EAAqBO,YAArB,EAAmC;MAClC,KAAKE,YAAL,CAAkBT,CAAlB,EAAqBO,YAArB;IACA;IAED;AACD;AACA;AACA;AACA;;;;WACC,kBAASG,QAAT,EAAiC;MAAA,IAAdtD,OAAc,uEAAJ,EAAI;MAChC,KAAKS,cAAL;MACA,OAAO,KAAK8C,SAAL,CAAeD,QAAf,EAAyBtD,OAAzB,CAAP;IACA;;;;;;SA9RmBH,e"}