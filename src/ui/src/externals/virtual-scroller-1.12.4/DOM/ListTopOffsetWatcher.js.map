{"version":3,"file":"ListTopOffsetWatcher.js","names":["setTimeout","clearTimeout","WATCH_LIST_TOP_OFFSET_INTERVAL","WATCH_LIST_TOP_OFFSET_MAX_DURATION","ListTopOffsetWatcher","getListTopOffset","onListTopOffsetChange","listTopOffset","listTopOffsetInsideScrollableContainer","undefined","start","_isActive","watchListTopOffset","watchListTopOffsetTimer","startedAt","Date","now","check"],"sources":["../../source/DOM/ListTopOffsetWatcher.js"],"sourcesContent":["// For some weird reason, in Chrome, `setTimeout()` would lag up to a second (or more) behind.\n// Turns out, Chrome developers have deprecated `setTimeout()` API entirely without asking anyone.\n// Replacing `setTimeout()` with `requestAnimationFrame()` can work around that Chrome bug.\n// https://github.com/bvaughn/react-virtualized/issues/722\nimport { setTimeout, clearTimeout } from 'request-animation-frame-timeout'\n\n// Refreshing two times every seconds seems reasonable.\nconst WATCH_LIST_TOP_OFFSET_INTERVAL = 500\n\n// Refreshing for 3 seconds after the initial page load seems reasonable.\nconst WATCH_LIST_TOP_OFFSET_MAX_DURATION = 3000\n\n// `VirtualScroller` calls `this.layout.layOut()` on mount,\n// but if the page styles are applied after `VirtualScroller` mounts\n// (for example, if styles are applied via javascript, like Webpack does)\n// then the list might not render correctly and it will only show the first item.\n// The reason is that in that case calling `.getListTopOffset()` on mount\n// returns \"incorrect\" `top` position because the styles haven't been applied yet.\n//\n// For example, consider a page:\n//\n// <div class=\"page\">\n//   <nav class=\"sidebar\">...</nav>\n//   <main>...</main>\n// </div>\n//\n// The sidebar is styled as `position: fixed`, but, until\n// the page styles have been applied, it's gonna be a regular `<div/>`\n// meaning that `<main/>` will be rendered below the sidebar\n// and will appear offscreen, and so it will only render the first item.\n//\n// Then, the page styles are loaded and applied, and the sidebar\n// is now `position: fixed`, so `<main/>` is now rendered at the top of the page,\n// but `VirtualScroller`'s `.render()` has already been called\n// and it won't re-render until the user scrolls or the window is resized.\n//\n// This type of a bug doesn't seem to occur in production, but it can appear\n// in development mode when using Webpack. The workaround `VirtualScroller`\n// implements for such cases is calling `.getListTopOffset()`\n// on the list container DOM element periodically (every second) to check\n// if the `top` coordinate has changed as a result of CSS being applied:\n// if it has then it recalculates the shown item indexes.\n//\n// Maybe this bug could occur in production when using Webpack chunks.\n// That depends on how a style of a chunk is added to the page:\n// if it's added via `javascript` after the page has been rendered\n// then this workaround will also work for that case.\n//\n// Another example would be a page having a really tall expanded \"accordion\"\n// section, below which a `VirtualScroller` list resides. If the user un-expands\n// such expanded \"accordion\" section, the list would become visible but\n// it wouldn't get re-rendered because no `scroll` event has occured,\n// and the list only re-renders automatically on `scroll` events.\n// To work around such cases, call `virtualScroller.updateLayout()` method manually.\n// The workaround below could be extended to refresh the list's top coordinate\n// indefinitely and at higher intervals, but why waste CPU time on that.\n// There doesn't seem to be any DOM API for tracking an element's top position.\n// There is `IntersectionObserver` API but it doesn't exactly do that.\n//\nexport default class ListTopOffsetWatcher {\n\tconstructor({\n\t\tgetListTopOffset,\n\t\tonListTopOffsetChange\n\t}) {\n\t\tthis.getListTopOffset = getListTopOffset\n\t\tthis.onListTopOffsetChange = onListTopOffsetChange\n\t}\n\n\tonListTopOffset(listTopOffset) {\n\t\tif (this.listTopOffsetInsideScrollableContainer === undefined) {\n\t\t\t// Start periodical checks of the list's top offset\n\t\t\t// in order to perform a re-layout in case it changes.\n\t\t\t// See the comments in `ListTopOffsetWatcher.js` file\n\t\t\t// on why can the list's top offset change, and in which circumstances.\n\t\t\tthis.start()\n\t\t}\n\t\tthis.listTopOffsetInsideScrollableContainer = listTopOffset\n\t}\n\n\tstart() {\n\t\tthis._isActive = true\n\t\tthis.watchListTopOffset()\n\t}\n\n\tisStarted() {\n\t\treturn this._isActive\n\t}\n\n\tstop() {\n\t\tthis._isActive = false\n\n\t\tif (this.watchListTopOffsetTimer) {\n\t\t\tclearTimeout(this.watchListTopOffsetTimer)\n\t\t\tthis.watchListTopOffsetTimer = undefined\n\t\t}\n\t}\n\n\twatchListTopOffset() {\n\t\tconst startedAt = Date.now()\n\t\tconst check = () => {\n\t\t\t// If `VirtualScroller` has been unmounted\n\t\t\t// while `setTimeout()` was waiting, then exit.\n\t\t\tif (!this._isActive) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Skip comparing `top` coordinate of the list\n\t\t\t// when this function is called for the first time.\n\t\t\tif (this.listTopOffsetInsideScrollableContainer !== undefined) {\n\t\t\t\t// Calling `this.getListTopOffset()` on an element\n\t\t\t\t// runs about 0.003 milliseconds on a modern desktop CPU,\n\t\t\t\t// so I guess it's fine calling it twice a second.\n\t\t\t\tif (this.getListTopOffset() !== this.listTopOffsetInsideScrollableContainer) {\n\t\t\t\t\tthis.onListTopOffsetChange()\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Compare `top` coordinate of the list twice a second\n\t\t\t// to find out if it has changed as a result of loading CSS styles.\n\t\t\t// The total duration of 3 seconds would be enough for any styles to load, I guess.\n\t\t\t// There could be other cases changing the `top` coordinate\n\t\t\t// of the list (like collapsing an \"accordeon\" panel above the list\n\t\t\t// without scrolling the page), but those cases should be handled\n\t\t\t// by manually calling `.updateLayout()` instance method on `VirtualScroller` instance.\n\t\t\tif (Date.now() - startedAt < WATCH_LIST_TOP_OFFSET_MAX_DURATION) {\n\t\t\t\tthis.watchListTopOffsetTimer = setTimeout(check, WATCH_LIST_TOP_OFFSET_INTERVAL)\n\t\t\t}\n\t\t}\n\t\t// Run the cycle.\n\t\tcheck()\n\t}\n}"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA,SAASA,UAAT,EAAqBC,YAArB,QAAyC,iCAAzC,C,CAEA;;AACA,IAAMC,8BAA8B,GAAG,GAAvC,C,CAEA;;AACA,IAAMC,kCAAkC,GAAG,IAA3C,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACqBC,oB;EACpB,oCAGG;IAAA,IAFFC,gBAEE,QAFFA,gBAEE;IAAA,IADFC,qBACE,QADFA,qBACE;;IAAA;;IACF,KAAKD,gBAAL,GAAwBA,gBAAxB;IACA,KAAKC,qBAAL,GAA6BA,qBAA7B;EACA;;;;WAED,yBAAgBC,aAAhB,EAA+B;MAC9B,IAAI,KAAKC,sCAAL,KAAgDC,SAApD,EAA+D;QAC9D;QACA;QACA;QACA;QACA,KAAKC,KAAL;MACA;;MACD,KAAKF,sCAAL,GAA8CD,aAA9C;IACA;;;WAED,iBAAQ;MACP,KAAKI,SAAL,GAAiB,IAAjB;MACA,KAAKC,kBAAL;IACA;;;WAED,qBAAY;MACX,OAAO,KAAKD,SAAZ;IACA;;;WAED,gBAAO;MACN,KAAKA,SAAL,GAAiB,KAAjB;;MAEA,IAAI,KAAKE,uBAAT,EAAkC;QACjCZ,YAAY,CAAC,KAAKY,uBAAN,CAAZ;QACA,KAAKA,uBAAL,GAA+BJ,SAA/B;MACA;IACD;;;WAED,8BAAqB;MAAA;;MACpB,IAAMK,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB;;MACA,IAAMC,KAAK,GAAG,SAARA,KAAQ,GAAM;QACnB;QACA;QACA,IAAI,CAAC,KAAI,CAACN,SAAV,EAAqB;UACpB;QACA,CALkB,CAMnB;QACA;;;QACA,IAAI,KAAI,CAACH,sCAAL,KAAgDC,SAApD,EAA+D;UAC9D;UACA;UACA;UACA,IAAI,KAAI,CAACJ,gBAAL,OAA4B,KAAI,CAACG,sCAArC,EAA6E;YAC5E,KAAI,CAACF,qBAAL;UACA;QACD,CAfkB,CAgBnB;QACA;QACA;QACA;QACA;QACA;QACA;;;QACA,IAAIS,IAAI,CAACC,GAAL,KAAaF,SAAb,GAAyBX,kCAA7B,EAAiE;UAChE,KAAI,CAACU,uBAAL,GAA+Bb,UAAU,CAACiB,KAAD,EAAQf,8BAAR,CAAzC;QACA;MACD,CA1BD,CAFoB,CA6BpB;;;MACAe,KAAK;IACL;;;;;;SArEmBb,oB"}