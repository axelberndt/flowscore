{"version":3,"file":"VirtualScroller.onContainerResize.js","names":["log","onContainerResize","previouslyCalculatedLayout","undefined","listHeightMeasurement","reset","itemsCount","newItemsWillBeRendered","count","getState","itemHeights","length","layout","newState","scrollableContainerWidth","scrollableContainer","getWidth","firstShownItemIndex","lastShownItemIndex","beforeItemsHeight","afterItemsHeight","Array","columnsCount","getActualColumnsCountForState","verticalSpacing","newColumnsCount","getActualColumnsCount","newFirstShownItemIndex","Math","floor","newLastShownItemIndex","min","ceil","getVerticalSpacing","getColumnsCount","shouldDiscardBeforeResizeItemHeights","beforeResize","shouldIncludeBeforeResizeValuesInState","snapshotBeforeResizeItemHeights","widthHasChanged","stateUpdate","updateState","prepend","replace"],"sources":["../source/VirtualScroller.onContainerResize.js"],"sourcesContent":["import log from './utility/debug.js'\n\nexport default function() {\n\tthis.onContainerResize = () => {\n\t\t// Reset \"previously calculated layout\".\n\t\t//\n\t\t// The \"previously calculated layout\" feature is not currently used.\n\t\t//\n\t\t// The current layout snapshot could be stored as a \"previously calculated layout\" variable\n\t\t// so that it could theoretically be used when calculating new layout incrementally\n\t\t// rather than from scratch, which would be an optimization.\n\t\t//\n\t\tthis.previouslyCalculatedLayout = undefined\n\n\t\t// Cancel any potential scheduled scroll position restoration.\n\t\tthis.listHeightMeasurement.reset()\n\n\t\t// Get the most recent items count.\n\t\t// If there're a \"pending\" `setItems()` call then use the items count from that call\n\t\t// instead of using the count of currently shown `items` from `state`.\n\t\t// A `setItems()` call is \"pending\" when `updateState()` operation is \"asynchronous\", that is\n\t\t// when `updateState()` calls aren't applied immediately, like in React.\n\t\tconst itemsCount = this.newItemsWillBeRendered\n\t\t\t? this.newItemsWillBeRendered.count\n\t\t\t: this.getState().itemHeights.length\n\n\t\t// If layout values have been calculated as a result of a \"pending\" `setItems()` call,\n\t\t// then don't discard those new layout values and use them instead of the ones from `state`.\n\t\t//\n\t\t// A `setItems()` call is \"pending\" when `updateState()` operation is \"asynchronous\", that is\n\t\t// when `updateState()` calls aren't applied immediately, like in React.\n\t\t//\n\t\tconst layout = this.newItemsWillBeRendered\n\t\t\t? this.newItemsWillBeRendered.layout\n\t\t\t: this.getState()\n\n\t\t// Update `VirtualScroller` state.\n\t\tconst newState = {\n\t\t\tscrollableContainerWidth: this.scrollableContainer.getWidth(),\n\n\t\t\t// This state update should also overwrite all the `state` properties\n\t\t\t// that are also updated in the \"on scroll\" handler (`getShownItemIndexes()`):\n\t\t\t//\n\t\t\t// * `firstShownItemIndex`\n\t\t\t// * `lastShownItemIndex`\n\t\t\t// * `beforeItemsHeight`\n\t\t\t// * `afterItemsHeight`\n\t\t\t//\n\t\t\t// That's because this `updateState()` update has a higher priority\n\t\t\t// than that of the \"on scroll\" handler, so it should overwrite\n\t\t\t// any potential state changes dispatched by the \"on scroll\" handler.\n\t\t\t//\n\t\t\t// All these properties might have changed, but they're not\n\t\t\t// recalculated here becase they'll be recalculated after\n\t\t\t// this new state is applied (rendered).\n\t\t\t//\n\t\t\tfirstShownItemIndex: layout.firstShownItemIndex,\n\t\t\tlastShownItemIndex: layout.lastShownItemIndex,\n\t\t\tbeforeItemsHeight: layout.beforeItemsHeight,\n\t\t\tafterItemsHeight: layout.afterItemsHeight,\n\n\t\t\t// Reset item heights, because if scrollable container's width (or height)\n\t\t\t// has changed, then the list width (or height) most likely also has changed,\n\t\t\t// and also some CSS `@media()` rules might have been added or removed.\n\t\t\t// So re-render the list entirely.\n\t\t\titemHeights: new Array(itemsCount),\n\n\t\t\tcolumnsCount: this.getActualColumnsCountForState(),\n\n\t\t\t// Re-measure vertical spacing after render because new CSS styles\n\t\t\t// might be applied for the new window width.\n\t\t\tverticalSpacing: undefined\n\t\t}\n\n\t\tconst { firstShownItemIndex, lastShownItemIndex } = layout\n\n\t\t// Get the `columnsCount` for the new window width.\n\t\tconst newColumnsCount = this.getActualColumnsCount()\n\n\t\t// Re-calculate `firstShownItemIndex` and `lastShownItemIndex`\n\t\t// based on the new `columnsCount` so that the whole row is visible.\n\t\tconst newFirstShownItemIndex = Math.floor(firstShownItemIndex / newColumnsCount) * newColumnsCount\n\t\tconst newLastShownItemIndex = Math.min(\n\t\t\tMath.ceil((lastShownItemIndex + 1) / newColumnsCount) * newColumnsCount,\n\t\t\titemsCount\n\t\t) - 1\n\n\t\t// Potentially update `firstShownItemIndex` if it needs to be adjusted in order to\n\t\t// correspond to the new `columnsCount`.\n\t\tif (newFirstShownItemIndex !== firstShownItemIndex) {\n\t\t\tlog('Columns Count changed from', this.getState().columnsCount || 1, 'to', newColumnsCount)\n\t\t\tlog('First Shown Item Index needs to change from', firstShownItemIndex, 'to', newFirstShownItemIndex)\n\t\t}\n\n\t\t// Always rewrite `firstShownItemIndex` and `lastShownItemIndex`\n\t\t// as part of the `state` update, even if it hasn't been modified.\n\t\t//\n\t\t// The reason is that there could be two subsequent `onResize()` calls:\n\t\t// the first one could be user resizing the window to half of its width,\n\t\t// resulting in an \"asynchronous\" `updateState()` call, and then, before that\n\t\t// `updateState()` call is applied, a second resize event happens when the user\n\t\t// has resized the window back to its original width, meaning that the\n\t\t// `columnsCount` is back to its original value.\n\t\t// In that case, the final `newFirstShownItemIndex` will be equal to the\n\t\t// original `firstShownItemIndex` that was in `state` before the user\n\t\t// has started resizing the window, so, in the end, `state.firstShownItemIndex`\n\t\t// property wouldn't have changed, but it still has to be part of the final\n\t\t// state update in order to overwrite the previous update of `firstShownItemIndex`\n\t\t// property that has been scheduled to be applied in state after the first resize\n\t\t// happened.\n\t\t//\n\t\tnewState.firstShownItemIndex = newFirstShownItemIndex\n\t\tnewState.lastShownItemIndex = newLastShownItemIndex\n\n\t\tconst verticalSpacing = this.getVerticalSpacing()\n\t\tconst columnsCount = this.getColumnsCount()\n\n\t\t// `beforeResize` is always overwritten in `state` here.\n\t\t// (once it has started being tracked in `state`)\n\t\tif (this.shouldDiscardBeforeResizeItemHeights() || newFirstShownItemIndex === 0) {\n\t\t\tif (this.beforeResize.shouldIncludeBeforeResizeValuesInState()) {\n\t\t\t\tnewState.beforeResize = undefined\n\t\t\t}\n\t\t}\n\t\t// Snapshot \"before resize\" values in order to preserve the currently\n\t\t// shown items' vertical position on screen so that there's no \"content jumping\".\n\t\telse {\n\t\t\t// Keep \"before resize\" values in order to preserve the currently\n\t\t\t// shown items' vertical position on screen so that there's no\n\t\t\t// \"content jumping\". These \"before resize\" values will be discarded\n\t\t\t// when (if) the user scrolls back to the top of the list.\n\t\t\tnewState.beforeResize = {\n\t\t\t\tverticalSpacing,\n\t\t\t\tcolumnsCount,\n\t\t\t\titemHeights: this.beforeResize.snapshotBeforeResizeItemHeights({\n\t\t\t\t\tfirstShownItemIndex,\n\t\t\t\t\tnewFirstShownItemIndex,\n\t\t\t\t\tnewColumnsCount\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// `this.widthHasChanged` tells `VirtualScroller` that it should\n\t\t// temporarily stop other updates (like \"on scroll\" updates) and wait\n\t\t// for the new `state` to be applied, after which the `onRender()`\n\t\t// function will clear this flag and perform a re-layout.\n\t\t//\n\t\t// A re-layout is required because the layout parameters calculated above\n\t\t// are approximate ones, and the exact item heights aren't known at this point.\n\t\t// So the `updateState()` call below is just to re-render the `VirtualScroller`.\n\t\t// After it has been re-rendered, it will measure item heights and then calculate\n\t\t// correct layout parameters.\n\t\t//\n\t\tthis.widthHasChanged = {\n\t\t\tstateUpdate: newState\n\t\t}\n\n\t\t// Rerender.\n\t\tthis.updateState(newState)\n\t}\n\n\t// Returns whether \"before resize\" item heights should be discarded\n\t// as a result of calling `setItems()` with a new set of items\n\t// when an asynchronous `updateState()` call inside that function\n\t// hasn't been applied yet.\n\t//\n\t// If `setItems()` update was an \"incremental\" one and no items\n\t// have been prepended, then `firstShownItemIndex` is preserved,\n\t// and all items' heights before it should be kept in order to\n\t// preserve the top offset of the first shown item so that there's\n\t// no \"content jumping\".\n\t//\n\t// If `setItems()` update was an \"incremental\" one but there're\n\t// some prepended items, then it means that now there're new items\n\t// with unknown heights at the top, so the top offset of the first\n\t// shown item won't be preserved because there're no \"before resize\"\n\t// heights of those items.\n\t//\n\t// If `setItems()` update was not an \"incremental\" one, then don't\n\t// attempt to restore previous item heights after a potential window\n\t// width change because all item heights have been reset.\n\t//\n\tthis.shouldDiscardBeforeResizeItemHeights = () => {\n\t\tif (this.newItemsWillBeRendered) {\n\t\t\tconst { prepend, replace } = this.newItemsWillBeRendered\n\t\t\treturn prepend || replace\n\t\t}\n\t}\n}"],"mappings":"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"}