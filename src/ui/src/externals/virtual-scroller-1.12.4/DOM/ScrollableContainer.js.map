{"version":3,"file":"ScrollableContainer.js","names":["ScrollableContainerNotReadyError","ScrollableContainer","getElement","getItemsContainerElement","scrollTop","scrollY","scrollTo","offsetWidth","offsetHeight","scrollableContainerTop","getBoundingClientRect","top","scrollableContainerBorderTopWidth","clientTop","itemsContainerTop","getScrollY","onScrollListener","element","addEventListener","removeEventListener","onResize","unobserve","ResizeObserver","resizeObserver","entries","entry","observe","unlistenGlobalResize","addGlobalResizeListener","itemsContainerElement","ScrollableWindowContainer","window","pageYOffset","innerWidth","innerHeight","borderTopWidth","document","body","onResizeListener","fullscreenElement","contains"],"sources":["../../source/DOM/ScrollableContainer.js"],"sourcesContent":["import ScrollableContainerNotReadyError from '../ScrollableContainerNotReadyError.js'\n\nexport default class ScrollableContainer {\n\t/**\n\t * Constructs a new \"scrollable container\" from an element.\n\t * @param {func} getElement — Returns the scrollable container element.\n\t * @param {func} getItemsContainerElement — Returns items \"container\" element.\n\t */\n\tconstructor(getElement, getItemsContainerElement) {\n\t\tthis.getElement = getElement\n\t\tthis.getItemsContainerElement = getItemsContainerElement\n\t}\n\n\t/**\n\t * Returns the current scroll position.\n\t * @return {number}\n\t */\n\tgetScrollY() {\n\t\treturn this.getElement().scrollTop\n\t}\n\n\t/**\n\t * Scrolls to a specific position.\n\t * @param {number} scrollY\n\t */\n\tscrollToY(scrollY) {\n\t\t// IE 11 doesn't seem to have a `.scrollTo()` method.\n\t\t// https://gitlab.com/catamphetamine/virtual-scroller/-/issues/10\n\t\t// https://stackoverflow.com/questions/39908825/window-scrollto-is-not-working-in-internet-explorer-11\n\t\tif (this.getElement().scrollTo) {\n\t\t\tthis.getElement().scrollTo(0, scrollY)\n\t\t} else {\n\t\t\tthis.getElement().scrollTop = scrollY\n\t\t}\n\t}\n\n\t/**\n\t * Returns \"scrollable container\" width,\n\t * i.e. the available width for its content.\n\t * @return {number}\n\t */\n\tgetWidth() {\n\t\tif (!this.getElement()) {\n\t\t\tthrow new ScrollableContainerNotReadyError()\n\t\t}\n\t\treturn this.getElement().offsetWidth\n\t}\n\n\t/**\n\t * Returns the height of the \"scrollable container\" itself.\n\t * Not to be confused with the height of \"scrollable container\"'s content.\n\t * @return {number}\n\t */\n\tgetHeight() {\n\t\tif (!this.getElement()) {\n\t\t\tthrow new ScrollableContainerNotReadyError()\n\t\t}\n\t\t// if (!this.getElement() && !precise) {\n\t\t// \treturn getScreenHeight()\n\t\t// }\n\t\treturn this.getElement().offsetHeight\n\t}\n\n\t/**\n\t * Returns a \"top offset\" of an items container element\n\t * relative to the \"scrollable container\"'s top edge.\n\t * @return {number}\n\t */\n\tgetItemsContainerTopOffset() {\n\t\tconst scrollableContainerTop = this.getElement().getBoundingClientRect().top\n\t\tconst scrollableContainerBorderTopWidth = this.getElement().clientTop\n\t\tconst itemsContainerTop = this.getItemsContainerElement().getBoundingClientRect().top\n\t\treturn (itemsContainerTop - scrollableContainerTop) + this.getScrollY() - scrollableContainerBorderTopWidth\n\t}\n\n\t// isVisible() {\n\t// \tconst { top, bottom } = this.getElement().getBoundingClientRect()\n\t// \treturn bottom > 0 && top < getScreenHeight()\n\t// }\n\n\t/**\n\t * Adds a \"scroll\" event listener to the \"scrollable container\".\n\t * @param {onScrollListener} Should be called whenever the scroll position inside the \"scrollable container\" (potentially) changes.\n\t * @return {function} Returns a function that stops listening.\n\t */\n\tonScroll(onScrollListener) {\n\t\tconst element = this.getElement()\n\t\telement.addEventListener('scroll', onScrollListener)\n\t\treturn () => element.removeEventListener('scroll', onScrollListener)\n\t}\n\n\t/**\n\t * Adds a \"resize\" event listener to the \"scrollable container\".\n\t * @param {onResize} Should be called whenever the \"scrollable container\"'s width or height (potentially) changes.\n   * @return {function} Returns a function that stops listening.\n\t */\n\tonResize(onResize) {\n\t\t// Watches \"scrollable container\"'s dimensions via a `ResizeObserver`.\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver\n\t\t// https://web.dev/resize-observer/\n\t\tlet unobserve\n\t\tif (typeof ResizeObserver !== 'undefined') {\n\t\t\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\t\t\t// \"one entry per observed element\".\n\t\t\t\t// https://web.dev/resize-observer/\n\t\t\t\t// `entry.target === this.getElement()`.\n\t\t\t\tconst entry = entries[0]\n\t\t\t\t// // If `entry.contentBoxSize` property is supported by the web browser.\n\t\t\t\t// if (entry.contentBoxSize) {\n\t\t\t\t// \t// https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentBoxSize\n\t\t\t\t// \tconst width = entry.contentBoxSize.inlineSize\n\t\t\t\t// \tconst height = entry.contentBoxSize.blockSize\n\t\t\t\t// }\n\t\t\t\tonResize()\n\t\t\t})\n\t\t\tconst element = this.getElement()\n\t\t\tresizeObserver.observe(element)\n\t\t\tunobserve = () => resizeObserver.unobserve(element)\n\t\t}\n\t\t// I guess, if window is resized, `onResize()` will be triggered twice:\n\t\t// once for window resize, and once for the scrollable container resize.\n\t\t// But `onResize()` also has an internal check: if the container size\n\t\t// hasn't changed since the previous time `onResize()` has been called,\n\t\t// then `onResize()` doesn't do anything, so, I guess, there shouldn't be\n\t\t// any \"performance implications\" of running the listener twice in such case.\n\t\tconst unlistenGlobalResize = addGlobalResizeListener(onResize, {\n\t\t\titemsContainerElement: this.getItemsContainerElement()\n\t\t})\n\t\treturn () => {\n\t\t\tif (unobserve) {\n\t\t\t\tunobserve()\n\t\t\t}\n\t\t\tunlistenGlobalResize()\n\t\t}\n\t}\n}\n\nexport class ScrollableWindowContainer extends ScrollableContainer {\n\t/**\n\t * Constructs a new window \"scrollable container\".\n\t * @param {func} getItemsContainerElement — Returns items \"container\" element.\n\t */\n\tconstructor(getItemsContainerElement) {\n\t\tsuper(() => window, getItemsContainerElement)\n\t}\n\n\t/**\n\t * Returns the current scroll position.\n\t * @return {number}\n\t */\n\tgetScrollY() {\n\t\t// `window.scrollY` is not supported by Internet Explorer.\n\t\treturn window.pageYOffset\n\t}\n\n\t/**\n\t * Returns \"scrollable container\" width,\n\t * i.e. the available width for its content.\n\t * @return {number}\n\t */\n\tgetWidth() {\n\t\t// https://javascript.info/size-and-scroll-window\n\t\t// `<!DOCTYPE html>` may be required in order for this to work correctly.\n\t\t// Includes scrollbar (if any).\n\t\t// Correctly reflects page zoom in iOS Safari.\n\t\t// (scales screen width accordingly).\n\t\t// But, includes scrollbar (if any).\n\t\treturn window.innerWidth\n\t}\n\n\t/**\n\t * Returns the height of the \"scrollable container\" itself.\n\t * Not to be confused with the height of \"scrollable container\"'s content.\n\t * @return {number}\n\t */\n\tgetHeight() {\n\t\t// https://javascript.info/size-and-scroll-window\n\t\t// `<!DOCTYPE html>` is required in order for this to work correctly.\n\t\t// Without it, the returned height would be the height of the entire document.\n\t\t// Includes scrollbar (if any).\n\t\t// Supports iOS Safari's dynamically shown/hidden\n\t\t// top URL bar and bottom actions bar.\n\t\t// https://codesandbox.io/s/elegant-fog-iddrh\n\t\t// Tested in IE 11.\n\t\t// It also correctly reflects page zoom in iOS Safari.\n\t\t// (scales screen height accordingly).\n\t\t// But, includes scrollbar (if any).\n\t\treturn window.innerHeight\n\t}\n\n\t/**\n\t * Returns a \"top offset\" of an items container element\n\t * relative to the \"scrollable container\"'s top edge.\n\t * @return {number}\n\t */\n\tgetItemsContainerTopOffset() {\n\t\tconst borderTopWidth = document.clientTop || document.body.clientTop || 0\n\t\treturn this.getItemsContainerElement().getBoundingClientRect().top + this.getScrollY() - borderTopWidth\n\t}\n\n\t/**\n\t * Adds a \"resize\" event listener to the \"scrollable container\".\n\t * @param {onScroll} Should be called whenever the \"scrollable container\"'s width or height (potentially) changes.\n\t * @return {function} Returns a function that stops listening.\n\t */\n\tonResize(onResize) {\n\t\treturn addGlobalResizeListener(onResize, {\n\t\t\titemsContainerElement: this.getItemsContainerElement()\n\t\t})\n\t}\n\n\t// isVisible() {\n\t// \treturn true\n\t// }\n}\n\n/**\n * Adds a \"resize\" event listener to the `window`.\n * @param {onResize} Should be called whenever the \"scrollable container\"'s width or height (potentially) changes.\n * @param  {Element} options.itemsContainerElement — The items \"container\" element, which is not the same as the \"scrollable container\" element. For example, \"scrollable container\" could be resized while the list element retaining its size. One such example is a user entering fullscreen mode on an HTML5 `<video/>` element: in that case, a \"resize\" event is triggered on a window, and window dimensions change to the user's screen size, but such \"resize\" event can be ignored because the list isn't visible until the user exits fullscreen mode.\n * @return {function} Returns a function that stops listening.\n */\nfunction addGlobalResizeListener(onResize, { itemsContainerElement }) {\n\tconst onResizeListener = () => {\n\t\t// By default, `VirtualScroller` always performs a re-layout\n\t\t// on window `resize` event. But browsers (Chrome, Firefox)\n\t\t// [trigger](https://developer.mozilla.org/en-US/docs/Web/API/Window/fullScreen#Notes)\n\t\t// window `resize` event also when a user switches into fullscreen mode:\n\t\t// for example, when a user is watching a video and double-clicks on it\n\t\t// to maximize it. And also when the user goes out of the fullscreen mode.\n\t\t// Each such fullscreen mode entering/exiting will trigger window `resize`\n\t\t// event that will it turn trigger a re-layout of `VirtualScroller`,\n\t\t// resulting in bad user experience. To prevent that, such cases are filtered out.\n\t\t// Some other workaround:\n\t\t// https://stackoverflow.com/questions/23770449/embedded-youtube-video-fullscreen-or-causing-resize\n\t\tif (document.fullscreenElement) {\n\t\t\t// If the fullscreened element doesn't contain the list\n\t\t\t// (and is not the list itself), then the layout hasn't been affected,\n\t\t\t// so don't perform a re-layout.\n\t\t\t//\n\t\t\t// For example, suppose there's a list of items, and some item contains a video.\n\t\t\t// If, upon clicking such video, it plays inline, and the user enters\n\t\t\t// fullscreen mode while playing such inline video, then the layout won't be\n\t\t\t// affected, and so such `resize` event should be ignored: when\n\t\t\t// `document.fullscreenElement` is in a separate \"branch\" relative to the\n\t\t\t// `container`.\n\t\t\t//\n\t\t\t// Another scenario: suppose that upon click, the video doesn't play inline,\n\t\t\t// but instead a \"Slideshow\" component is open, with the video shown at the\n\t\t\t// center of the screen in an overlay. If then the user enters fullscreen mode,\n\t\t\t// the layout wouldn't be affected too, so such `resize` event should also be\n\t\t\t// ignored: when `document.fullscreenElement` is inside the `container`.\n\t\t\t//\n\t\t\tif (document.fullscreenElement.contains(itemsContainerElement)) {\n\t\t\t\t// The element is either the `container`'s ancestor,\n\t\t\t\t// Or is the `container` itself.\n\t\t\t\t// (`a.contains(b)` includes the `a === b` case).\n\t\t\t\t// So the `resize` event will affect the `container`'s dimensions.\n\t\t\t} else {\n\t\t\t\t// The element is either inside the `container`,\n\t\t\t\t// Or is in a separate tree.\n\t\t\t\t// So the `resize` event won't affect the `container`'s dimensions.\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tonResize()\n\t}\n\twindow.addEventListener('resize', onResizeListener)\n\treturn () => window.removeEventListener('resize', onResizeListener)\n}"],"mappings":"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"}