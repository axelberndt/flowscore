{"version":3,"file":"VirtualScroller.layout.js","names":["setTimeout","clearTimeout","log","warn","isDebug","reportError","LAYOUT_REASON","ItemNotRenderedError","onUpdateShownItemIndexes","reason","stateUpdate","skip","updateState","newItemsWillBeRendered","widthHasChanged","_isResizing","getItemsCount","scroll","cancelScheduledLayout","cancelLayoutTimer","updateShownItemIndexes","call","startedAt","Date","now","getShownItemIndexes","firstShownItemIndex","lastShownItemIndex","shownItemsHeight","firstNonMeasuredItemIndex","listHeightMeasurement","hasSnapshot","getAnchorItemIndex","undefined","validateWillBeHiddenItemHeightsAreAccurate","beforeItemsHeight","layout","getBeforeItemsHeight","afterItemsHeight","getAfterItemsHeight","layoutDuration","bypass","SLOW_LAYOUT_DURATION","getColumnsCount","itemHeights","getAverage","getState","slice","itemStates","onBeforeShowItems","items","previouslyCalculatedLayout","getCoordinatesOfVisibleAreaInsideTheList","visibleAreaBounds","getVisibleAreaBounds","latestLayoutVisibleArea","listTopOffsetInsideScrollableContainer","getListTopOffsetInsideScrollableContainer","top","bottom","itemsCount","visibleAreaInsideTheList","isVisible","itemsContainer","getHeight","getPrerenderMargin","getNonVisibleListShownItemIndexes","isValid","i","previouslyMeasuredItemHeight","actualItemHeight","remeasureItemHeight","updatePreviouslyCalculatedLayoutOnItemHeightChange","previousHeight","newHeight","prevLayout","heightDifference","listTopOffset","scrollableContainer","getItemsContainerTopOffset","listTopOffsetWatcher","onListTopOffset","_onItemHeightDidChange","error","message","_isActive","waitingForRender","updateLayoutAfterRenderBecauseItemHeightChanged","ITEM_HEIGHT_CHANGED","itemHeightsThatChangedWhileNewItemsWereBeingRendered","String","renderAheadMarginRatio","onItemInitialRender","measureItemHeightsAndSpacing","measureItemHeights","verticalSpacing","measureVerticalSpacingIfNotMeasured","layoutTimer","layoutTimerStateUpdate","scheduleLayoutTimer"],"sources":["../source/VirtualScroller.layout.js"],"sourcesContent":["// For some weird reason, in Chrome, `setTimeout()` would lag up to a second (or more) behind.\n// Turns out, Chrome developers have deprecated `setTimeout()` API entirely without asking anyone.\n// Replacing `setTimeout()` with `requestAnimationFrame()` can work around that Chrome bug.\n// https://github.com/bvaughn/react-virtualized/issues/722\nimport { setTimeout, clearTimeout } from 'request-animation-frame-timeout'\n\nimport log, { warn, isDebug, reportError } from './utility/debug.js'\nimport { LAYOUT_REASON } from './Layout.js'\n\nimport ItemNotRenderedError from './ItemNotRenderedError.js'\n\nexport default function() {\n\tthis.onUpdateShownItemIndexes = ({ reason, stateUpdate }) => {\n\t\t// In case of \"don't do anything\".\n\t\tconst skip = () => {\n\t\t\tif (stateUpdate) {\n\t\t\t\tthis.updateState(stateUpdate)\n\t\t\t}\n\t\t}\n\n\t\t// If new `items` have been set and are waiting to be applied,\n\t\t// or if the viewport width has changed requiring a re-layout,\n\t\t// then temporarily stop all other updates like \"on scroll\" updates.\n\t\t// This prevents `state` being inconsistent, because, for example,\n\t\t// both `setItems()` and this function could update `VirtualScroller` state\n\t\t// and having them operate in parallel could result in incorrectly calculated\n\t\t// `beforeItemsHeight` / `afterItemsHeight` / `firstShownItemIndex` /\n\t\t// `lastShownItemIndex`, because, when operating in parallel, this function\n\t\t// would have different `items` than the `setItems()` function, so their\n\t\t// results could diverge.\n\t\tif (this.newItemsWillBeRendered || this.widthHasChanged || this._isResizing) {\n\t\t\treturn skip()\n\t\t}\n\n\t\t// If there're no items then there's no need to re-layout anything.\n\t\tif (this.getItemsCount() === 0) {\n\t\t\treturn skip()\n\t\t}\n\n\t\t// Cancel a \"re-layout when user stops scrolling\" timer.\n\t\tthis.scroll.cancelScheduledLayout()\n\n\t\t// Cancel a re-layout that is scheduled to run at the next \"frame\",\n\t\t// because a re-layout will be performed right now.\n\t\tstateUpdate = this.cancelLayoutTimer({ stateUpdate })\n\n\t\t// Perform a re-layout.\n\t\tlog(`~ Update Layout (on ${reason}) ~`)\n\t\tupdateShownItemIndexes.call(this, { stateUpdate })\n\t}\n\n\t/**\n\t * Updates the \"from\" and \"to\" shown item indexes.\n\t * If the list is visible and some of the items being shown are new\n\t * and are required to be measured first, then\n\t * `firstNonMeasuredItemIndex` is defined.\n\t * If the list is visible and all items being shown have been encountered\n\t * (and measured) before, then `firstNonMeasuredItemIndex` is `undefined`.\n\t *\n\t * The `stateUpdate` parameter is just an optional \"additional\" state update.\n\t */\n\tfunction updateShownItemIndexes({ stateUpdate }) {\n\t\tconst startedAt = Date.now()\n\n\t\t// Get shown item indexes.\n\t\tlet {\n\t\t\tfirstShownItemIndex,\n\t\t\tlastShownItemIndex,\n\t\t\tshownItemsHeight,\n\t\t\tfirstNonMeasuredItemIndex\n\t\t} = getShownItemIndexes.call(this)\n\n\t\t// If scroll position is scheduled to be restored after render,\n\t\t// then the \"anchor\" item must be rendered, and all of the prepended\n\t\t// items before it, all in a single pass. This way, all of the\n\t\t// prepended items' heights could be measured right after the render\n\t\t// has finished, and the scroll position can then be immediately restored.\n\t\tif (this.listHeightMeasurement.hasSnapshot()) {\n\t\t\tif (lastShownItemIndex < this.listHeightMeasurement.getAnchorItemIndex()) {\n\t\t\t\tlastShownItemIndex = this.listHeightMeasurement.getAnchorItemIndex()\n\t\t\t}\n\t\t\t// `firstShownItemIndex` is always `0` when prepending items.\n\t\t\t// And `lastShownItemIndex` always covers all prepended items in this case.\n\t\t\t// None of the prepended items have been rendered before,\n\t\t\t// so their heights are unknown. The code at the start of this function\n\t\t\t// did therefore set `firstNonMeasuredItemIndex` to non-`undefined`\n\t\t\t// in order to render just the first prepended item in order to\n\t\t\t// measure it, and only then make a decision on how many other\n\t\t\t// prepended items to render. But since we've instructed the code\n\t\t\t// to show all of the prepended items at once, there's no need to\n\t\t\t// \"redo layout after render\". Additionally, if layout was re-done\n\t\t\t// after render, then there would be a short interval of visual\n\t\t\t// \"jitter\" due to the scroll position not being restored because it'd\n\t\t\t// wait for the second layout to finish instead of being restored\n\t\t\t// right after the first one.\n\t\t\tfirstNonMeasuredItemIndex = undefined\n\t\t}\n\n\t\t// Validate the heights of items to be hidden on next render.\n\t\t// For example, a user could click a \"Show more\" button,\n\t\t// or an \"Expand YouTube video\" button, which would result\n\t\t// in the actual height of the list item being different\n\t\t// from what has been initially measured in `this.itemHeights[i]`,\n\t\t// if the developer didn't call `.setItemState(i, newState)` and `.onItemHeightDidChange(i)`.\n\t\tif (!validateWillBeHiddenItemHeightsAreAccurate.call(this, firstShownItemIndex, lastShownItemIndex)) {\n\t\t\tlog('~ Because some of the will-be-hidden item heights (listed above) have changed since they\\'ve last been measured, redo layout. ~')\n\t\t\t// Redo layout, now with the correct item heights.\n\t\t\treturn updateShownItemIndexes.call(this, { stateUpdate });\n\t\t}\n\n\t\t// Measure \"before\" items height.\n\t\tconst beforeItemsHeight = this.layout.getBeforeItemsHeight(\n\t\t\tfirstShownItemIndex\n\t\t)\n\n\t\t// Measure \"after\" items height.\n\t\tconst afterItemsHeight = this.layout.getAfterItemsHeight(\n\t\t\tlastShownItemIndex,\n\t\t\tthis.getItemsCount()\n\t\t)\n\n\t\tconst layoutDuration = Date.now() - startedAt\n\n\t\t// Debugging.\n\t\tlog('~ Calculated Layout' + (this.bypass ? ' (bypass)' : '') + ' ~')\n\t\tif (layoutDuration < SLOW_LAYOUT_DURATION) {\n\t\t\t// log('Calculated in', layoutDuration, 'ms')\n\t\t} else {\n\t\t\twarn('Layout calculated in', layoutDuration, 'ms')\n\t\t}\n\t\tif (this.getColumnsCount()) {\n\t\t\tlog('Columns count', this.getColumnsCount())\n\t\t}\n\t\tlog('First shown item index', firstShownItemIndex)\n\t\tlog('Last shown item index', lastShownItemIndex)\n\t\tlog('Before items height', beforeItemsHeight)\n\t\tlog('After items height (actual or estimated)', afterItemsHeight)\n\t\tlog('Average item height (used for estimated after items height calculation)', this.itemHeights.getAverage())\n\t\tif (isDebug()) {\n\t\t\tlog('Item heights', this.getState().itemHeights.slice())\n\t\t\tlog('Item states', this.getState().itemStates.slice())\n\t\t}\n\n\t\t// Optionally preload items to be rendered.\n\t\tthis.onBeforeShowItems(\n\t\t\tthis.getState().items,\n\t\t\tthis.getState().itemHeights,\n\t\t\tfirstShownItemIndex,\n\t\t\tlastShownItemIndex\n\t\t)\n\n\t\t// Set `this.firstNonMeasuredItemIndex`.\n\t\tthis.firstNonMeasuredItemIndex = firstNonMeasuredItemIndex\n\t\t// if (firstNonMeasuredItemIndex !== undefined) {\n\t\t// \tlog('Non-measured item index that will be measured at next layout', firstNonMeasuredItemIndex)\n\t\t// }\n\n\t\t// Set \"previously calculated layout\".\n\t\t//\n\t\t// The \"previously calculated layout\" feature is not currently used.\n\t\t//\n\t\t// The current layout snapshot could be stored as a \"previously calculated layout\" variable\n\t\t// so that it could theoretically be used when calculating new layout incrementally\n\t\t// rather than from scratch, which would be an optimization.\n\t\t//\n\t\t// Currently, this feature is not used, and `shownItemsHeight` property\n\t\t// is not returned at all, so don't set any \"previously calculated layout\".\n\t\t//\n\t\tif (shownItemsHeight === undefined) {\n\t\t\tthis.previouslyCalculatedLayout = undefined\n\t\t} else {\n\t\t\t// If \"previously calculated layout\" feature would be implmeneted,\n\t\t\t// then this code would set \"previously calculate layout\" instance variable.\n\t\t\t//\n\t\t\t// What for would this instance variable be used?\n\t\t\t//\n\t\t\t// Instead of using a `this.previouslyCalculatedLayout` instance variable,\n\t\t\t// this code could use `this.getState()` because it reflects what's currently on screen,\n\t\t\t// but there's a single edge case when it could go out of sync —\n\t\t\t// updating item heights externally via `.onItemHeightDidChange(i)`.\n\t\t\t//\n\t\t\t// If, for example, an item height was updated externally via `.onItemHeightDidChange(i)`\n\t\t\t// then `this.getState().itemHeights` would get updated immediately but\n\t\t\t// `this.getState().beforeItemsHeight` or `this.getState().afterItemsHeight`\n\t\t\t// would still correspond to the previous item height, so those would be \"stale\".\n\t\t\t// On the other hand, same values in `this.previouslyCalculatedLayout` instance variable\n\t\t\t// can also be updated immediately, so they won't go out of sync with the updated item height.\n\t\t\t// That seems the only edge case when using a separate `this.previouslyCalculatedLayout`\n\t\t\t// instance variable instead of using `this.getState()` would theoretically be justified.\n\t\t\t//\n\t\t\tthis.previouslyCalculatedLayout = {\n\t\t\t\tfirstShownItemIndex,\n\t\t\t\tlastShownItemIndex,\n\t\t\t\tbeforeItemsHeight,\n\t\t\t\tshownItemsHeight\n\t\t\t}\n\t\t}\n\n\t\t// Update `VirtualScroller` state.\n\t\t// `VirtualScroller` automatically re-renders on state updates.\n\t\t//\n\t\t// All `state` properties updated here should be overwritten in\n\t\t// the implementation of `setItems()` and `onResize()` methods\n\t\t// so that the `state` is not left in an inconsistent state\n\t\t// whenever there're concurrent `updateState()` updates that could\n\t\t// possibly conflict with one another — instead, those state updates\n\t\t// should overwrite each other in terms of priority.\n\t\t// These \"on scroll\" updates have the lowest priority compared to\n\t\t// the state updates originating from `setItems()` and `onResize()` methods.\n\t\t//\n\t\tthis.updateState({\n\t\t\tfirstShownItemIndex,\n\t\t\tlastShownItemIndex,\n\t\t\tbeforeItemsHeight,\n\t\t\tafterItemsHeight,\n\t\t\t...stateUpdate\n\t\t})\n\t}\n\n\tfunction getCoordinatesOfVisibleAreaInsideTheList() {\n\t\tconst visibleAreaBounds = this.scroll.getVisibleAreaBounds()\n\t\tthis.latestLayoutVisibleArea = visibleAreaBounds\n\n\t\t// Subtract the top offset of the list inside the scrollable container.\n\t\tconst listTopOffsetInsideScrollableContainer = this.getListTopOffsetInsideScrollableContainer()\n\t\treturn {\n\t\t\ttop: visibleAreaBounds.top - listTopOffsetInsideScrollableContainer,\n\t\t\tbottom: visibleAreaBounds.bottom - listTopOffsetInsideScrollableContainer\n\t\t}\n\t}\n\n\tfunction getShownItemIndexes() {\n\t\tconst itemsCount = this.getItemsCount()\n\n\t\tconst visibleAreaInsideTheList = getCoordinatesOfVisibleAreaInsideTheList.call(this)\n\n\t\tif (this.bypass) {\n\t\t\treturn {\n\t\t\t\tfirstShownItemIndex: 0,\n\t\t\t\tlastShownItemIndex: itemsCount - 1,\n\t\t\t\t// shownItemsHeight: this.getState().itemHeights.reduce((sum, itemHeight) => sum + itemHeight, 0)\n\t\t\t}\n\t\t}\n\n\t\t// Find the indexes of the items that are currently visible\n\t\t// (or close to being visible) in the scrollable container.\n\t\t// For scrollable containers other than the main screen, it could also\n\t\t// check the visibility of such scrollable container itself, because it\n\t\t// might be not visible.\n\t\t// If such kind of an optimization would hypothetically be implemented,\n\t\t// then it would also require listening for \"scroll\" events on the screen.\n\t\t// Overall, I suppose that such \"actual visibility\" feature would be\n\t\t// a very minor optimization and not something I'd deal with.\n\t\tconst isVisible = visibleAreaInsideTheList.top < this.itemsContainer.getHeight() + this.layout.getPrerenderMargin() && visibleAreaInsideTheList.bottom > 0 - this.layout.getPrerenderMargin()\n\t\tif (!isVisible) {\n\t\t\tlog('The entire list is off-screen. No items are visible.')\n\t\t\treturn this.layout.getNonVisibleListShownItemIndexes()\n\t\t}\n\n\t\t// Get shown item indexes.\n\t\treturn this.layout.getShownItemIndexes({\n\t\t\titemsCount: this.getItemsCount(),\n\t\t\tvisibleAreaInsideTheList\n\t\t})\n\t}\n\n\t/**\n\t * Validates the heights of items to be hidden on next render.\n\t * For example, a user could click a \"Show more\" button,\n\t * or an \"Expand YouTube video\" button, which would result\n\t * in the actual height of the list item being different\n\t * from what has been initially measured in `this.itemHeights[i]`,\n\t * if the developer didn't call `.setItemState(i, newState)` and `.onItemHeightDidChange(i)`.\n\t */\n\tfunction validateWillBeHiddenItemHeightsAreAccurate(firstShownItemIndex, lastShownItemIndex) {\n\t\tlet isValid = true\n\t\tlet i = this.getState().firstShownItemIndex\n\t\twhile (i <= this.getState().lastShownItemIndex) {\n\t\t\tif (i >= firstShownItemIndex && i <= lastShownItemIndex) {\n\t\t\t\t// The item's still visible.\n\t\t\t} else {\n\t\t\t\t// The item will be hidden. Re-measure its height.\n\t\t\t\t// The rationale is that there could be a situation when an item's\n\t\t\t\t// height has changed, and the developer has properly added an\n\t\t\t\t// `.onItemHeightDidChange(i)` call to notify `VirtualScroller`\n\t\t\t\t// about that change, but at the same time that wouldn't work.\n\t\t\t\t// For example, suppose there's a list of several items on a page,\n\t\t\t\t// and those items are in \"minimized\" state (having height 100px).\n\t\t\t\t// Then, a user clicks an \"Expand all items\" button, and all items\n\t\t\t\t// in the list are expanded (expanded item height is gonna be 700px).\n\t\t\t\t// `VirtualScroller` demands that `.onItemHeightDidChange(i)` is called\n\t\t\t\t// in such cases, and the developer has properly added the code to do that.\n\t\t\t\t// So, if there were 10 \"minimized\" items visible on a page, then there\n\t\t\t\t// will be 10 individual `.onItemHeightDidChange(i)` calls. No issues so far.\n\t\t\t\t// But, as the first `.onItemHeightDidChange(i)` call executes, it immediately\n\t\t\t\t// (\"synchronously\") triggers a re-layout, and that re-layout finds out\n\t\t\t\t// that now, because the first item is big, it occupies most of the screen\n\t\t\t\t// space, and only the first 3 items are visible on screen instead of 10,\n\t\t\t\t// and so it leaves the first 3 items mounted and unmounts the rest 7.\n\t\t\t\t// Then, after `VirtualScroller` has rerendered, the code returns to\n\t\t\t\t// where it was executing, and calls `.onItemHeightDidChange(i)` for the\n\t\t\t\t// second item. It also triggers an immediate re-layout that finds out\n\t\t\t\t// that only the first 2 items are visible on screen, and it unmounts\n\t\t\t\t// the third one too. After that, it calls `.onItemHeightDidChange(i)`\n\t\t\t\t// for the third item, but that item is no longer rendered, so its height\n\t\t\t\t// can't be measured, and the same's for all the rest of the original 10 items.\n\t\t\t\t// So, even though the developer has written their code properly, the\n\t\t\t\t// `VirtualScroller` still ends up having incorrect `itemHeights[]`:\n\t\t\t\t// `[700px, 700px, 100px, 100px, 100px, 100px, 100px, 100px, 100px, 100px]`\n\t\t\t\t// while it should have been `700px` for all of them.\n\t\t\t\t// To work around such issues, every item's height is re-measured before it\n\t\t\t\t// gets hidden.\n\t\t\t\tconst previouslyMeasuredItemHeight = this.getState().itemHeights[i]\n\t\t\t\tconst actualItemHeight = remeasureItemHeight.call(this, i)\n\t\t\t\tif (actualItemHeight !== previouslyMeasuredItemHeight) {\n\t\t\t\t\tif (isValid) {\n\t\t\t\t\t\tlog('~ Validate will-be-hidden item heights. ~')\n\t\t\t\t\t\t// Update or reset previously calculated layout.\n\t\t\t\t\t\tupdatePreviouslyCalculatedLayoutOnItemHeightChange.call(this, i, previouslyMeasuredItemHeight, actualItemHeight)\n\t\t\t\t\t}\n\t\t\t\t\tisValid = false\n\t\t\t\t\twarn('Item index', i, 'is no longer visible and will be unmounted. Its height has changed from', previouslyMeasuredItemHeight, 'to', actualItemHeight, 'since it was last measured. This is not necessarily a bug, and could happen, for example, on screen width change, or when there\\'re several `onItemHeightDidChange(i)` calls issued at the same time, and the first one triggers a re-layout before the rest of them have had a chance to be executed.')\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\treturn isValid\n\t}\n\n\tfunction remeasureItemHeight(i) {\n\t\tconst { firstShownItemIndex } = this.getState()\n\t\treturn this.itemHeights.remeasureItemHeight(i, firstShownItemIndex)\n\t}\n\n\t// Updates the snapshot of the current layout when an item's height changes.\n\t//\n\t// The \"previously calculated layout\" feature is not currently used.\n\t//\n\t// The current layout snapshot could be stored as a \"previously calculated layout\" variable\n\t// so that it could theoretically be used when calculating new layout incrementally\n\t// rather than from scratch, which would be an optimization.\n\t//\n\tfunction updatePreviouslyCalculatedLayoutOnItemHeightChange(i, previousHeight, newHeight) {\n\t\tconst prevLayout = this.previouslyCalculatedLayout\n\t\tif (prevLayout) {\n\t\t\tconst heightDifference = newHeight - previousHeight\n\t\t\tif (i < prevLayout.firstShownItemIndex) {\n\t\t\t\t// Patch `prevLayout`'s `.beforeItemsHeight`.\n\t\t\t\tprevLayout.beforeItemsHeight += heightDifference\n\t\t\t} else if (i > prevLayout.lastShownItemIndex) {\n\t\t\t\t// Could patch `.afterItemsHeight` of `prevLayout` here,\n\t\t\t\t// if `.afterItemsHeight` property existed in `prevLayout`.\n\t\t\t\tif (prevLayout.afterItemsHeight !== undefined) {\n\t\t\t\t\tprevLayout.afterItemsHeight += heightDifference\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Patch `prevLayout`'s shown items height.\n\t\t\t\tprevLayout.shownItemsHeight += newHeight - previousHeight\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns the list's top offset relative to the scrollable container's top edge.\n\t * @return {number}\n\t */\n\tthis.getListTopOffsetInsideScrollableContainer = () => {\n\t\tconst listTopOffset = this.scrollableContainer.getItemsContainerTopOffset()\n\t\tif (this.listTopOffsetWatcher) {\n\t\t\tthis.listTopOffsetWatcher.onListTopOffset(listTopOffset)\n\t\t}\n\t\treturn listTopOffset\n\t}\n\n\tthis._onItemHeightDidChange = (i) => {\n\t\tlog('~ On Item Height Did Change was called ~')\n\t\tlog('Item index', i)\n\n\t\tconst {\n\t\t\titemHeights,\n\t\t\tfirstShownItemIndex,\n\t\t\tlastShownItemIndex\n\t\t} = this.getState()\n\n\t\t// Check if the item is still rendered.\n\t\tif (!(i >= firstShownItemIndex && i <= lastShownItemIndex)) {\n\t\t\t// There could be valid cases when an item is no longer rendered\n\t\t\t// by the time `.onItemHeightDidChange(i)` gets called.\n\t\t\t// For example, suppose there's a list of several items on a page,\n\t\t\t// and those items are in \"minimized\" state (having height 100px).\n\t\t\t// Then, a user clicks an \"Expand all items\" button, and all items\n\t\t\t// in the list are expanded (expanded item height is gonna be 700px).\n\t\t\t// `VirtualScroller` demands that `.onItemHeightDidChange(i)` is called\n\t\t\t// in such cases, and the developer has properly added the code to do that.\n\t\t\t// So, if there were 10 \"minimized\" items visible on a page, then there\n\t\t\t// will be 10 individual `.onItemHeightDidChange(i)` calls. No issues so far.\n\t\t\t// But, as the first `.onItemHeightDidChange(i)` call executes, it immediately\n\t\t\t// (\"synchronously\") triggers a re-layout, and that re-layout finds out\n\t\t\t// that now, because the first item is big, it occupies most of the screen\n\t\t\t// space, and only the first 3 items are visible on screen instead of 10,\n\t\t\t// and so it leaves the first 3 items mounted and unmounts the rest 7.\n\t\t\t// Then, after `VirtualScroller` has rerendered, the code returns to\n\t\t\t// where it was executing, and calls `.onItemHeightDidChange(i)` for the\n\t\t\t// second item. It also triggers an immediate re-layout that finds out\n\t\t\t// that only the first 2 items are visible on screen, and it unmounts\n\t\t\t// the third one too. After that, it calls `.onItemHeightDidChange(i)`\n\t\t\t// for the third item, but that item is no longer rendered, so its height\n\t\t\t// can't be measured, and the same's for all the rest of the original 10 items.\n\t\t\t// So, even though the developer has written their code properly, there're\n\t\t\t// still situations when the item could be no longer rendered by the time\n\t\t\t// `.onItemHeightDidChange(i)` gets called.\n\t\t\treturn warn('The item is no longer rendered. This is not necessarily a bug, and could happen, for example, when when a developer calls `onItemHeightDidChange(i)` while looping through a batch of items.')\n\t\t}\n\n\t\tconst previousHeight = itemHeights[i]\n\t\tif (previousHeight === undefined) {\n\t\t\treturn reportError(`\"onItemHeightDidChange()\" has been called for item index ${i} but the item hasn't been rendered before.`)\n\t\t}\n\n\t\tlog('~ Re-measure item height ~')\n\n\t\tlet newHeight\n\n\t\ttry {\n\t\t\tnewHeight = remeasureItemHeight.call(this, i)\n\t\t} catch (error) {\n\t\t\t// Successfully finishing an `onItemHeightDidChange(i)` call is not considered\n\t\t\t// critical for `VirtualScroller`'s operation, so such errors could be ignored.\n\t\t\tif (error instanceof ItemNotRenderedError) {\n\t\t\t\treturn reportError(`\"onItemHeightDidChange()\" has been called for item index ${i} but the item is not currently rendered and can\\'t be measured. The exact error was: ${error.message}`)\n\t\t\t}\n\t\t}\n\n\t\tlog('Previous height', previousHeight)\n\t\tlog('New height', newHeight)\n\n\t\tif (previousHeight !== newHeight) {\n\t\t\tlog('~ Item height has changed. Should update layout. ~')\n\n\t\t\t// Update or reset a previously calculated layout with the new item height\n\t\t\t// so that the potential future \"diff\"s based on that \"previously calculated\" layout\n\t\t\t// would be correct.\n\t\t\t//\n\t\t\t// The \"previously calculated layout\" feature is not currently used\n\t\t\t// so this function call doesn't really affect anything.\n\t\t\t//\n\t\t\tupdatePreviouslyCalculatedLayoutOnItemHeightChange.call(this, i, previousHeight, newHeight)\n\n\t\t\t// Recalculate layout.\n\t\t\t//\n\t\t\t// If the `VirtualScroller` is already waiting for a state update to be rendered,\n\t\t\t// delay `onItemHeightDidChange(i)`'s re-layout until that state update is rendered.\n\t\t\t// The reason is that React `<VirtualScroller/>`'s `onHeightDidChange()` is meant to\n\t\t\t// be called inside `useLayoutEffect()` hook. Due to how React is implemented internally,\n\t\t\t// that might happen in the middle of the currently pending `setState()` operation\n\t\t\t// being applied, resulting in weird \"race condition\" bugs.\n\t\t\t//\n\t\t\tif (this._isActive) {\n\t\t\t\tif (this.waitingForRender) {\n\t\t\t\t\tlog('~ Another state update is already waiting to be rendered. Delay the layout update until then. ~')\n\t\t\t\t\tthis.updateLayoutAfterRenderBecauseItemHeightChanged = true\n\t\t\t\t} else {\n\t\t\t\t\tthis.onUpdateShownItemIndexes({ reason: LAYOUT_REASON.ITEM_HEIGHT_CHANGED })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there was a request for `setState()` with new `items`, then the changes\n\t\t\t// to `currentState.itemHeights[]` made above in a `remeasureItemHeight()` call\n\t\t\t// would be overwritten when that pending `setState()` call gets applied.\n\t\t\t// To fix that, the updates to current `itemHeights[]` are noted in\n\t\t\t// `this.itemHeightsThatChangedWhileNewItemsWereBeingRendered` variable.\n\t\t\t// That variable is then checked when the `setState()` call with the new `items`\n\t\t\t// has been updated.\n\t\t\tif (this.newItemsWillBeRendered) {\n\t\t\t\tif (!this.itemHeightsThatChangedWhileNewItemsWereBeingRendered) {\n\t\t\t\t\tthis.itemHeightsThatChangedWhileNewItemsWereBeingRendered = {}\n\t\t\t\t}\n\t\t\t\tthis.itemHeightsThatChangedWhileNewItemsWereBeingRendered[String(i)] = newHeight\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.getPrerenderMargin = () => {\n\t\t// The list component renders not only the items that're currently visible\n\t\t// but also the items that lie within some extra vertical margin (called\n\t\t// \"prerender margin\") on top and bottom for future scrolling: this way,\n\t\t// there'll be significantly less layout recalculations as the user scrolls,\n\t\t// because now it doesn't have to recalculate layout on each scroll event.\n\t\t// By default, the \"prerender margin\" is equal to the screen height:\n\t\t// this seems to be the optimal value for \"Page Up\" / \"Page Down\" navigation\n\t\t// and optimized mouse wheel scrolling (a user is unlikely to continuously\n\t\t// scroll past the screen height, because they'd stop to read through\n\t\t// the newly visible items first, and when they do stop scrolling, that's\n\t\t// when layout gets recalculated).\n\t\tconst renderAheadMarginRatio = 3 // in scrollable container heights.\n\t\treturn this.scrollableContainer.getHeight() * renderAheadMarginRatio\n\t}\n\n\t/**\n\t * Calls `onItemFirstRender()` for items that haven't been\n\t * \"seen\" previously.\n\t * @param  {any[]} items\n\t * @param  {number[]} itemHeights\n\t * @param  {number} firstShownItemIndex\n\t * @param  {number} lastShownItemIndex\n\t */\n\tthis.onBeforeShowItems = (\n\t\titems,\n\t\titemHeights,\n\t\tfirstShownItemIndex,\n\t\tlastShownItemIndex\n\t) => {\n\t\tif (this.onItemInitialRender) {\n\t\t\tlet i = firstShownItemIndex\n\t\t\twhile (i <= lastShownItemIndex) {\n\t\t\t\tif (itemHeights[i] === undefined) {\n\t\t\t\t\tthis.onItemInitialRender(items[i])\n\t\t\t\t}\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.measureItemHeightsAndSpacing = () => {\n\t\t// Measure \"newly shown\" item heights.\n\t\t// Also re-validate already measured items' heights.\n\t\tthis.itemHeights.measureItemHeights(\n\t\t\tthis.getState().firstShownItemIndex,\n\t\t\tthis.getState().lastShownItemIndex\n\t\t)\n\n\t\t// Measure item vertical spacing, if required.\n\t\tconst verticalSpacing = this.measureVerticalSpacingIfNotMeasured()\n\n\t\t// Return a state update if vertical spacing has been measured.\n\t\t// Doesn't set `verticalSpacing: 0` in `state` because it is effectively\n\t\t// same as `verticalSpacing: undefined` in terms code behavior and calculations.\n\t\t// Not having `verticalSpacing: 0` in `state` just makes the `state` object\n\t\t// a bit more cleaner and a bit less cluttered (easier for inspection).\n\t\tif (verticalSpacing && verticalSpacing !== 0) {\n\t\t\t// Return a state update.\n\t\t\t// Sets `verticalSpacing` property in `state`.\n\t\t\treturn {\n\t\t\t\tverticalSpacing\n\t\t\t}\n\t\t}\n\t}\n\n\tthis.cancelLayoutTimer = ({ stateUpdate }) => {\n\t\tif (this.layoutTimer) {\n\t\t\tclearTimeout(this.layoutTimer)\n\t\t\tthis.layoutTimer = undefined\n\t\t\t// Merge state updates.\n\t\t\tif (stateUpdate || this.layoutTimerStateUpdate) {\n\t\t\t\tstateUpdate = {\n\t\t\t\t\t...this.layoutTimerStateUpdate,\n\t\t\t\t\t...stateUpdate\n\t\t\t\t}\n\t\t\t\tthis.layoutTimerStateUpdate = undefined\n\t\t\t\treturn stateUpdate\n\t\t\t}\n\t\t} else {\n\t\t\treturn stateUpdate\n\t\t}\n\t}\n\n\tthis.scheduleLayoutTimer = ({ reason, stateUpdate }) => {\n\t\tthis.layoutTimerStateUpdate = stateUpdate\n\t\tthis.layoutTimer = setTimeout(() => {\n\t\t\tthis.layoutTimerStateUpdate = undefined\n\t\t\tthis.layoutTimer = undefined\n\t\t\tthis.onUpdateShownItemIndexes({\n\t\t\t\treason,\n\t\t\t\tstateUpdate\n\t\t\t})\n\t\t}, 0)\n\t}\n}\n\nconst SLOW_LAYOUT_DURATION = 15 // in milliseconds."],"mappings":"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"}