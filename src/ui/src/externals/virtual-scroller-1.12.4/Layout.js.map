{"version":3,"file":"Layout.js","names":["log","warn","ScrollableContainerNotReadyError","Layout","bypass","getInitialEstimatedItemHeight","getInitialEstimatedVisibleItemRowsCount","measureItemsBatchSize","getPrerenderMargin","getVerticalSpacing","getVerticalSpacingBeforeResize","getColumnsCount","getColumnsCountBeforeResize","getItemHeight","getItemHeightBeforeResize","getBeforeResizeItemsCount","getAverageItemHeight","getMaxVisibleAreaHeight","getPreviouslyCalculatedLayout","name","getValue","defaultValue","error","itemsCount","columnsCount","beforeStart","firstShownItemIndex","lastShownItemIndex","getLastShownItemIndex","getInitialLastShownItemIndex","getInitialLayoutValueWithFallback","beforeItemsHeight","afterItemsHeight","estimatedRowsCount","getEstimatedRowsCountForHeight","isNaN","Error","Math","min","height","estimatedItemHeight","getEstimatedItemHeight","verticalSpacing","ceil","averageItemHeight","prependedItemsCount","appendedItemsCount","shouldRestoreScrollPosition","onResetGridLayout","appendedRowsCount","addedHeightAfter","prependedRowsCount","addedHeightBefore","shownItemsCountBeforeItemsUpdate","afterItemsCount","i","nonMeasuredAreaHeight","indexOfTheFirstItemInTheRow","itemsCountToRenderForMeasurement","Infinity","undefined","firstNonMeasuredItemIndex","visibleAreaInsideTheList","indexes","_getShownItemIndex","fromIndex","findFirstShownItemIndex","getNonVisibleListShownItemIndexes","findLastShownItemIndex","parameters","beforeResize","beforeResizeItemsCount","notFound","beforeResizeItemsHeight","floor","currentRowFirstItemIndex","hasMoreRows","verticalSpacingAfterCurrentRow","currentRowHeight","columnIndex","itemHeight","getItemNotMeasuredIndexes","bottom","max","itemsHeightFromFirstRowToThisRow","rowStepsIntoVisibleAreaTop","top","rowStepsOutOfVisibleAreaBottomOrIsAtTheBorder","layout","beforeItemsCount","getBeforeItemsHeight","rowHeight","lastShownRowIndex","topOffsetInsideScrollableContainer","beforeResizeRowsCount","maxBeforeResizeRowsCount","beforeResizeRowIndex","itemRowIndex","rowIndex","LAYOUT_REASON","SCROLL","STOPPED_SCROLLING","MANUAL","STARTED","NON_MEASURED_ITEMS_HAVE_BEEN_MEASURED","VIEWPORT_WIDTH_CHANGED","VIEWPORT_HEIGHT_CHANGED","VIEWPORT_SIZE_UNCHANGED","ITEM_HEIGHT_CHANGED","ITEMS_CHANGED","TOP_OFFSET_CHANGED"],"sources":["../source/Layout.js"],"sourcesContent":["import log, { warn } from './utility/debug.js'\nimport ScrollableContainerNotReadyError from './ScrollableContainerNotReadyError.js'\n\nexport default class Layout {\n\tconstructor({\n\t\tbypass,\n\t\tgetInitialEstimatedItemHeight,\n\t\tgetInitialEstimatedVisibleItemRowsCount,\n\t\tmeasureItemsBatchSize,\n\t\tgetPrerenderMargin,\n\t\tgetVerticalSpacing,\n\t\tgetVerticalSpacingBeforeResize,\n\t\tgetColumnsCount,\n\t\tgetColumnsCountBeforeResize,\n\t\tgetItemHeight,\n\t\tgetItemHeightBeforeResize,\n\t\tgetBeforeResizeItemsCount,\n\t\tgetAverageItemHeight,\n\t\tgetMaxVisibleAreaHeight,\n\t\tgetPreviouslyCalculatedLayout\n\t}) {\n\t\tthis.bypass = bypass\n\t\tthis.getInitialEstimatedItemHeight = getInitialEstimatedItemHeight\n\t\tthis.getInitialEstimatedVisibleItemRowsCount = getInitialEstimatedVisibleItemRowsCount\n\t\tthis.measureItemsBatchSize = measureItemsBatchSize\n\t\tthis.getPrerenderMargin = getPrerenderMargin\n\t\tthis.getVerticalSpacing = getVerticalSpacing\n\t\tthis.getVerticalSpacingBeforeResize = getVerticalSpacingBeforeResize\n\t\tthis.getColumnsCount = getColumnsCount\n\t\tthis.getColumnsCountBeforeResize = getColumnsCountBeforeResize\n\t\tthis.getItemHeight = getItemHeight\n\t\tthis.getItemHeightBeforeResize = getItemHeightBeforeResize\n\t\tthis.getBeforeResizeItemsCount = getBeforeResizeItemsCount\n\t\tthis.getAverageItemHeight = getAverageItemHeight\n\t\tthis.getMaxVisibleAreaHeight = getMaxVisibleAreaHeight\n\t\t//\n\t\t// The \"previously calculated layout\" feature is not currently used.\n\t\t//\n\t\t// The current layout snapshot could be stored as a \"previously calculated layout\" variable\n\t\t// so that it could theoretically be used when calculating new layout incrementally\n\t\t// rather than from scratch, which would be an optimization.\n\t\t//\n\t\tthis.getPreviouslyCalculatedLayout = getPreviouslyCalculatedLayout\n\t}\n\n\t// React `<VirtualScroller/>` component attempts to create the initial state\n\t// before the component tree has mounted. This could result in an inability to\n\t// calculate some initial layout values like `columnsCount` or `lastShownItemIndex`.\n\t// Such errors aren't considered critical because layout will be re-calculated\n\t// after the component mounts. The workaround is to use some sane default values\n\t// until the scrollable container has mounted.\n\tgetInitialLayoutValueWithFallback(name, getValue, defaultValue) {\n\t\ttry {\n\t\t\treturn getValue()\n\t\t} catch (error) {\n\t\t\tif (error instanceof ScrollableContainerNotReadyError) {\n\t\t\t\tlog(`Scrollable container size is not known at this point, so \"${name}\" can't be calculated yet. Default to`, defaultValue);\n\t\t\t\treturn defaultValue\n\t\t\t} else {\n\t\t\t\tthrow error\n\t\t\t}\n\t\t}\n\t}\n\n\tgetInitialLayoutValues({\n\t\titemsCount,\n\t\tcolumnsCount,\n\t\tbeforeStart\n\t}) {\n\t\tlet firstShownItemIndex\n\t\tlet lastShownItemIndex\n\t\t// If there're no items then `firstShownItemIndex` stays `undefined`.\n\t\tif (itemsCount > 0) {\n\t\t\tconst getLastShownItemIndex = () => {\n\t\t\t\treturn this.getInitialLastShownItemIndex({\n\t\t\t\t\titemsCount,\n\t\t\t\t\tcolumnsCount,\n\t\t\t\t\tfirstShownItemIndex\n\t\t\t\t})\n\t\t\t}\n\t\t\tfirstShownItemIndex = 0\n\t\t\tlastShownItemIndex = beforeStart\n\t\t\t\t? this.getInitialLayoutValueWithFallback(\n\t\t\t\t\t'lastShownItemIndex',\n\t\t\t\t\tgetLastShownItemIndex,\n\t\t\t\t\t0\n\t\t\t\t)\n\t\t\t\t: getLastShownItemIndex()\n\t\t}\n\t\treturn {\n\t\t\tbeforeItemsHeight: 0,\n\t\t\tafterItemsHeight: 0,\n\t\t\tfirstShownItemIndex,\n\t\t\tlastShownItemIndex\n\t\t}\n\t}\n\n\tgetInitialLastShownItemIndex({\n\t\titemsCount,\n\t\tcolumnsCount,\n\t\tfirstShownItemIndex\n\t}) {\n\t\tif (this.bypass) {\n\t\t\treturn itemsCount - 1\n\t\t}\n\t\t// On server side, at initialization time,\n\t\t// `scrollableContainer` is `undefined`,\n\t\t// so default to `1` estimated rows count.\n\t\tlet estimatedRowsCount = 1\n\t\tif (this.getMaxVisibleAreaHeight()) {\n\t\t\testimatedRowsCount = this.getEstimatedRowsCountForHeight(this.getMaxVisibleAreaHeight() + this.getPrerenderMargin())\n\t\t} else if (this.getInitialEstimatedVisibleItemRowsCount) {\n\t\t\testimatedRowsCount = this.getInitialEstimatedVisibleItemRowsCount()\n\t\t\tif (isNaN(estimatedRowsCount)) {\n\t\t\t\tthrow new Error('[virtual-scroller] `getEstimatedVisibleItemRowsCount()` must return a number')\n\t\t\t}\n\t\t}\n\t\treturn Math.min(\n\t\t\tfirstShownItemIndex + (estimatedRowsCount * columnsCount - 1),\n\t\t\titemsCount - 1\n\t\t)\n\t}\n\n\tgetEstimatedRowsCountForHeight(height) {\n\t\tconst estimatedItemHeight = this.getEstimatedItemHeight()\n\t\tconst verticalSpacing = this.getVerticalSpacing()\n\t\tif (estimatedItemHeight) {\n\t\t\treturn Math.ceil((height + verticalSpacing) / (estimatedItemHeight + verticalSpacing))\n\t\t} else {\n\t\t\t// If no items have been rendered yet, and no `estimatedItemHeight` option\n\t\t\t// has been passed, then default to `1` estimated rows count in any `height`.\n\t\t\treturn 1\n\t\t}\n\t}\n\n\t/**\n\t * Returns estimated list item height.\n\t * (depends on which items have been previously rendered and measured).\n\t * @return {number}\n\t */\n\tgetEstimatedItemHeight() {\n\t\tconst averageItemHeight = this.getAverageItemHeight()\n\t\tif (averageItemHeight) {\n\t\t\treturn averageItemHeight\n\t\t}\n\t\tif (this.getInitialEstimatedItemHeight) {\n\t\t\tconst estimatedItemHeight = this.getInitialEstimatedItemHeight()\n\t\t\tif (isNaN(estimatedItemHeight)) {\n\t\t\t\tthrow new Error('[virtual-scroller] `getInitialEstimatedItemHeight()` must return a number')\n\t\t\t}\n\t\t\treturn estimatedItemHeight\n\t\t}\n\t\treturn 0\n\t}\n\n\tgetLayoutUpdateForItemsDiff({\n\t\tfirstShownItemIndex,\n\t\tlastShownItemIndex,\n\t\tbeforeItemsHeight,\n\t\tafterItemsHeight\n\t}, {\n\t\tprependedItemsCount,\n\t\tappendedItemsCount\n\t}, {\n\t\titemsCount,\n\t\tcolumnsCount,\n\t\tshouldRestoreScrollPosition,\n\t\tonResetGridLayout\n\t}) {\n\t\t// const layoutUpdate = {}\n\n\t\t// If the layout stays the same, then simply increase\n\t\t// the top and bottom margins proportionally to the amount\n\t\t// of the items added.\n\t\tconst averageItemHeight = this.getAverageItemHeight()\n\t\tconst verticalSpacing = this.getVerticalSpacing()\n\n\t\tif (appendedItemsCount > 0) {\n\t\t\tconst appendedRowsCount = Math.ceil(appendedItemsCount / columnsCount)\n\t\t\tconst addedHeightAfter = appendedRowsCount * (verticalSpacing + averageItemHeight)\n\n\t\t\tafterItemsHeight += addedHeightAfter\n\n\t\t\t// layoutUpdate = {\n\t\t\t// \t...layoutUpdate,\n\t\t\t// \tafterItemsHeight\n\t\t\t// }\n\t\t}\n\n\t\tif (prependedItemsCount > 0) {\n\t\t\tconst prependedRowsCount = Math.ceil(prependedItemsCount / columnsCount)\n\t\t\tconst addedHeightBefore = prependedRowsCount * (averageItemHeight + verticalSpacing)\n\n\t\t\tfirstShownItemIndex += prependedItemsCount\n\t\t\tlastShownItemIndex += prependedItemsCount\n\t\t\tbeforeItemsHeight += addedHeightBefore\n\n\t\t\t// If the currently shown items position on screen should be preserved\n\t\t\t// when prepending new items, then it means that:\n\t\t\t// * The current scroll position should be snapshotted.\n\t\t\t// * The current list height should be snapshotted.\n\t\t\t// * All prepended items should be shown so that their height could be\n\t\t\t//   measured after they're rendered. Based on the prepended items' height,\n\t\t\t//   the scroll position will be restored so that there's no \"jump of content\".\n\t\t\tif (shouldRestoreScrollPosition) {\n\t\t\t\tfirstShownItemIndex = 0\n\t\t\t\tbeforeItemsHeight = 0\n\t\t\t}\n\n\t\t\tif (prependedItemsCount % columnsCount > 0) {\n\t\t\t\t// Rows will be rebalanced as a result of prepending new items,\n\t\t\t\t// and row heights can change as a result, so re-layout items\n\t\t\t\t// after they've been measured (after the upcoming re-render).\n\t\t\t\t//\n\t\t\t\t// For example, consider a web page where item rows are `display: flex`.\n\t\t\t\t// Suppose there're 3 columns and it shows items from 4 to 6.\n\t\t\t\t//\n\t\t\t\t// ------------------------------------------\n\t\t\t\t// | Apples are  | Bananas    | Cranberries |\n\t\t\t\t// | green       |            |             |\n\t\t\t\t// ------------------------------------------\n\t\t\t\t// | Dates       | Elderberry | Figs are    |\n\t\t\t\t// |             |            | tasty       |\n\t\t\t\t// ------------------------------------------\n\t\t\t\t//\n\t\t\t\t// Now, 1 item gets prepended. As a result, all existing rows will have\n\t\t\t\t// a different set of items, which means that the row heights will change.\n\t\t\t\t//\n\t\t\t\t// ------------------------------------------\n\t\t\t\t// | Zucchini    | Apples are | Bananas     |\n\t\t\t\t// |             | green      |             |\n\t\t\t\t// ------------------------------------------\n\t\t\t\t// | Cranberries | Dates      | Elderberry  |\n\t\t\t\t// ------------------------------------------\n\t\t\t\t// | Figs        |\n\t\t\t\t// | are tasty   |\n\t\t\t\t// ---------------\n\t\t\t\t//\n\t\t\t\t// As it can be seen above, the second row's height has changed from 2 to 1.\n\t\t\t\t// Not only that, but `itemHeights` have changed as well, so if you thought\n\t\t\t\t// that the library could easily recalculate row heights using `Math.max()` — \n\t\t\t\t// turns out it's not always the case.\n\t\t\t\t//\n\t\t\t\t// There could be an explicit opt-in option for automatically recalculating\n\t\t\t\t// row heights, but I don't want to write code for such an extremely rare\n\t\t\t\t// use case. Instead, use the `getColumnsCount()` parameter function when\n\t\t\t\t// fetching previous items.\n\n\t\t\t\tonResetGridLayout()\n\n\t\t\t\twarn('~ Prepended items count', prependedItemsCount, 'is not divisible by Columns Count', columnsCount, '~')\n\t\t\t\twarn('Layout reset required')\n\n\t\t\t\tconst shownItemsCountBeforeItemsUpdate = lastShownItemIndex - firstShownItemIndex + 1\n\n\t\t\t\tfirstShownItemIndex = 0\n\t\t\t\tbeforeItemsHeight = 0\n\n\t\t\t\tif (!shouldRestoreScrollPosition) {\n\t\t\t\t\t// Limit shown items count if too many items have been prepended.\n\t\t\t\t\tif (prependedItemsCount > shownItemsCountBeforeItemsUpdate) {\n\t\t\t\t\t\tlastShownItemIndex = this.getInitialLastShownItemIndex({\n\t\t\t\t\t\t\titemsCount,\n\t\t\t\t\t\t\tcolumnsCount,\n\t\t\t\t\t\t\tfirstShownItemIndex\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\t// Approximate `afterItemsHeight` calculation.\n\t\t\t\t\t\tconst afterItemsCount = itemsCount - (lastShownItemIndex + 1)\n\t\t\t\t\t\tafterItemsHeight = Math.ceil(afterItemsCount / columnsCount) * (verticalSpacing + averageItemHeight)\n\n\t\t\t\t\t\t// layoutUpdate = {\n\t\t\t\t\t\t// \t...layoutUpdate,\n\t\t\t\t\t\t// \tafterItemsHeight\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// layoutUpdate = {\n\t\t\t// \t...layoutUpdate,\n\t\t\t// \tbeforeItemsHeight,\n\t\t\t// \tfirstShownItemIndex,\n\t\t\t// \tlastShownItemIndex\n\t\t\t// }\n\t\t}\n\n\t\t// return layoutUpdate\n\n\t\t// Overwrite all four props in all scenarios.\n\t\t// The reason is that only this way subsequent `setItems()` calls\n\t\t// will be truly \"stateless\" when a chain of `setItems()` calls\n\t\t// could be replaced with just the last one in a scenario when\n\t\t// `updateState()` calls are \"asynchronous\" (delayed execution).\n\t\t//\n\t\t// So, for example, the user calls `setItems()` with one set of items.\n\t\t// A `updateState()` call has been dispatched but the `state` hasn't been updated yet.\n\t\t// Then the user calls `setItems()` with another set of items.\n\t\t// If this function only returned a minimal set of properties that actually change,\n\t\t// the other layout properties of the second `setItems()` call wouldn't overwrite the ones\n\t\t// scheduled for update during the first `setItems()` call, resulting in an inconsistent `state`.\n\t\t//\n\t\t// For example, the first `setItems()` call does a `updateState()` call where it updates\n\t\t// `afterItemsHeight`, and then the second `setItems()` call only updates `beforeItemsHeight`\n\t\t// and `firstShownItemIndex` and `lastShownItemIndex`. If the second `setItems()` call was to\n\t\t// overwrite any effects of the pending-but-not-yet-applied first `setItems()` call, it would\n\t\t// have to call `updateState()` with an `afterItemsHeight` property too, even though it hasn't change.\n\t\t// That would be just to revert the change to `afterItemsHeight` state property already scheduled\n\t\t// by the first `setItems()` call.\n\t\t//\n\t\treturn {\n\t\t\tbeforeItemsHeight,\n\t\t\tafterItemsHeight,\n\t\t\tfirstShownItemIndex,\n\t\t\tlastShownItemIndex\n\t\t}\n\t}\n\n\t// If an item that hasn't been shown (and measured) yet is encountered\n\t// then show such item and then retry after it has been measured.\n\tgetItemNotMeasuredIndexes(i, {\n\t\titemsCount,\n\t\tfirstShownItemIndex,\n\t\tnonMeasuredAreaHeight,\n\t\tindexOfTheFirstItemInTheRow\n\t}) {\n\t\tlog('Item index', i, 'height is required for calculations but hasn\\'t been measured yet. Mark the item as \"shown\", rerender the list, measure the item\\'s height and redo the layout.')\n\n\t\tconst columnsCount = this.getColumnsCount()\n\n\t\tconst itemsCountToRenderForMeasurement = Math.min(\n\t\t\tthis.getEstimatedRowsCountForHeight(nonMeasuredAreaHeight) * columnsCount,\n\t\t\tthis.measureItemsBatchSize || Infinity,\n\t\t)\n\n\t\tif (firstShownItemIndex === undefined) {\n\t\t\tfirstShownItemIndex = indexOfTheFirstItemInTheRow\n\t\t}\n\n\t\tconst lastShownItemIndex = Math.min(\n\t\t\tindexOfTheFirstItemInTheRow + itemsCountToRenderForMeasurement - 1,\n\t\t\t// Guard against index overflow.\n\t\t\titemsCount - 1\n\t\t)\n\n\t\treturn {\n\t\t\tfirstNonMeasuredItemIndex: i,\n\t\t\tfirstShownItemIndex,\n\t\t\tlastShownItemIndex\n\t\t}\n\t}\n\n\t/**\n\t * Finds the indexes of the currently visible items.\n\t * @return {object} `{ firstShownItemIndex: number, lastShownItemIndex: number, firstNonMeasuredItemIndex: number? }`\n\t */\n\tgetShownItemIndexes({\n\t\titemsCount,\n\t\tvisibleAreaInsideTheList\n\t}) {\n\t\tlet indexes = this._getShownItemIndex({\n\t\t\titemsCount,\n\t\t\tfromIndex: 0,\n\t\t\tvisibleAreaInsideTheList,\n\t\t\tfindFirstShownItemIndex: true\n\t\t})\n\n\t\tif (indexes === null) {\n\t\t\treturn this.getNonVisibleListShownItemIndexes()\n\t\t}\n\n\t\tif (indexes.firstNonMeasuredItemIndex !== undefined) {\n\t\t\treturn indexes\n\t\t}\n\n\t\tconst { firstShownItemIndex, beforeItemsHeight } = indexes\n\n\t\tindexes = this._getShownItemIndex({\n\t\t\titemsCount,\n\t\t\tfromIndex: firstShownItemIndex,\n\t\t\tbeforeItemsHeight,\n\t\t\tvisibleAreaInsideTheList,\n\t\t\tfindLastShownItemIndex: true\n\t\t})\n\n\t\tif (indexes === null) {\n\t\t\treturn this.getNonVisibleListShownItemIndexes()\n\t\t}\n\n\t\tif (indexes.firstNonMeasuredItemIndex !== undefined) {\n\t\t\treturn indexes\n\t\t}\n\n\t\tconst { lastShownItemIndex } = indexes\n\n\t\treturn {\n\t\t\tfirstShownItemIndex,\n\t\t\tlastShownItemIndex\n\t\t}\n\t}\n\n\t_getShownItemIndex(parameters) {\n\t\tconst {\n\t\t\tbeforeResize,\n\t\t\titemsCount,\n\t\t\tvisibleAreaInsideTheList,\n\t\t\tfindFirstShownItemIndex,\n\t\t\tfindLastShownItemIndex,\n\t\t\t// backwards\n\t\t} = parameters\n\n\t\tlet {\n\t\t\tfromIndex,\n\t\t\tbeforeItemsHeight\n\t\t} = parameters\n\n\t\t// This function could potentially also use `this.getPreviouslyCalculatedLayout()`\n\t\t// in order to skip calculating visible item indexes from scratch\n\t\t// and instead just calculate the difference from a \"previously calculated layout\".\n\t\t//\n\t\t// I did a simple test in a web browser and found out that running the following\n\t\t// piece of code is less than 10 milliseconds:\n\t\t//\n\t\t// var startedAt = Date.now()\n\t\t// var i = 0\n\t\t// while (i < 1000000) {\n\t\t//   i++\n\t\t// }\n\t\t// console.log(Date.now() - startedAt)\n\t\t//\n\t\t// Which becomes negligible in my project's use case (a couple thousands items max).\n\t\t//\n\t\t// If someone would attempt to use a \"previously calculated layout\" here\n\t\t// then `shownItemsHeight` would also have to be returned from this function:\n\t\t// the total height of all shown items including vertical spacing between them.\n\t\t//\n\t\t// If \"previously calculated layout\" would be used then it would first find\n\t\t// `firstShownItemIndex` and then find `lastShownItemIndex` as part of two\n\t\t// separate calls of this function, each with or without `backwards` flag,\n\t\t// depending on whether `visibleAreaInsideTheList.top` and `visibleAreaInsideTheList.top`\n\t\t// have shifted up or down.\n\n\t\tlet firstShownItemIndex\n\t\tlet lastShownItemIndex\n\n\t\t// It's not always required to pass `beforeItemsHeight` parameter:\n\t\t// when `fromIndex` is `0`, it's also assumed to be `0`.\n\t\tif (fromIndex === 0) {\n\t\t\tbeforeItemsHeight = 0\n\t\t}\n\n\t\tif (beforeItemsHeight === undefined) {\n\t\t\tthrow new Error('[virtual-scroller] `beforeItemsHeight` not passed to `Layout.getShownItemIndexes()` when starting from index ' + fromIndex);\n\t\t}\n\n\t\t// const backwards = false\n\t\t// while (backwards ? i >= 0 : i < itemsCount) {}\n\n\t\tif (!beforeResize) {\n\t\t\tconst beforeResizeItemsCount = this.getBeforeResizeItemsCount()\n\t\t\tif (beforeResizeItemsCount > fromIndex) {\n\t\t\t\t// First search for the item in \"before resize\" items.\n\t\t\t\tconst {\n\t\t\t\t\tnotFound,\n\t\t\t\t\tbeforeItemsHeight: beforeResizeItemsHeight,\n\t\t\t\t\tfirstShownItemIndex,\n\t\t\t\t\tlastShownItemIndex\n\t\t\t\t} = this._getShownItemIndex({\n\t\t\t\t\t...parameters,\n\t\t\t\t\tbeforeResize: true,\n\t\t\t\t\titemsCount: beforeResizeItemsCount\n\t\t\t\t})\n\n\t\t\t\t// If the item was not found in \"before resize\" items\n\t\t\t\t// then search in regular items skipping \"before resize\" ones.\n\t\t\t\tif (notFound) {\n\t\t\t\t\tbeforeItemsHeight = beforeResizeItemsHeight\n\t\t\t\t\tfromIndex += beforeResizeItemsCount\n\t\t\t\t} else {\n\t\t\t\t\t// If the item was found in \"before resize\" items\n\t\t\t\t\t// then return the result.\n\t\t\t\t\t// Rebalance first / last shown item indexes based on\n\t\t\t\t\t// the current columns count, if required.\n\t\t\t\t\tconst columnsCount = this.getColumnsCount()\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfirstShownItemIndex: firstShownItemIndex === undefined\n\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t: Math.floor(firstShownItemIndex / columnsCount) * columnsCount,\n\t\t\t\t\t\tlastShownItemIndex: lastShownItemIndex === undefined\n\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t: Math.floor(lastShownItemIndex / columnsCount) * columnsCount,\n\t\t\t\t\t\tbeforeItemsHeight: beforeResizeItemsHeight\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst columnsCount = beforeResize ? this.getColumnsCountBeforeResize() : this.getColumnsCount()\n\t\tconst verticalSpacing = beforeResize ? this.getVerticalSpacingBeforeResize() : this.getVerticalSpacing()\n\n\t\tlet i = fromIndex\n\t\twhile (i < itemsCount) {\n\t\t\tconst currentRowFirstItemIndex = i\n\n\t\t\tconst hasMoreRows = itemsCount > currentRowFirstItemIndex + columnsCount\n\t\t\tconst verticalSpacingAfterCurrentRow = hasMoreRows ? verticalSpacing : 0\n\n\t\t\tlet currentRowHeight = 0\n\n\t\t\t// Calculate current row height.\n\t\t\tlet columnIndex = 0\n\t\t\twhile (columnIndex < columnsCount && i < itemsCount) {\n\t\t\t\tconst itemHeight = beforeResize ? this.getItemHeightBeforeResize(i) : this.getItemHeight(i)\n\n\t\t\t\t// If this item hasn't been measured yet (or re-measured after a resize)\n\t\t\t\t// then mark it as the first non-measured one.\n\t\t\t\t//\n\t\t\t\t// Can't happen by definition when `beforeResize` parameter is `true`.\n\t\t\t\t//\n\t\t\t\tif (itemHeight === undefined) {\n\t\t\t\t\treturn this.getItemNotMeasuredIndexes(i, {\n\t\t\t\t\t\titemsCount,\n\t\t\t\t\t\tfirstShownItemIndex: findLastShownItemIndex ? fromIndex : undefined,\n\t\t\t\t\t\tindexOfTheFirstItemInTheRow: currentRowFirstItemIndex,\n\t\t\t\t\t\tnonMeasuredAreaHeight: (visibleAreaInsideTheList.bottom + this.getPrerenderMargin()) - beforeItemsHeight\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tcurrentRowHeight = Math.max(currentRowHeight, itemHeight)\n\n\t\t\t\tcolumnIndex++\n\t\t\t\ti++\n\t\t\t}\n\n\t\t\tconst itemsHeightFromFirstRowToThisRow = beforeItemsHeight + currentRowHeight\n\n\t\t\tconst rowStepsIntoVisibleAreaTop = itemsHeightFromFirstRowToThisRow > visibleAreaInsideTheList.top - this.getPrerenderMargin()\n\t\t\tconst rowStepsOutOfVisibleAreaBottomOrIsAtTheBorder = itemsHeightFromFirstRowToThisRow + verticalSpacingAfterCurrentRow >= visibleAreaInsideTheList.bottom + this.getPrerenderMargin()\n\n\t\t\t// if (backwards) {\n\t\t\t// \tif (findFirstShownItemIndex) {\n\t\t\t// \t\tif (rowStepsOutOfVisibleAreaTop) {\n\t\t\t// \t\t\treturn {\n\t\t\t// \t\t\t\tfirstShownItemIndex: currentRowFirstItemIndex + columnsCount\n\t\t\t// \t\t\t}\n\t\t\t// \t\t}\n\t\t\t// \t} else if (findLastShownItemIndex) {\n\t\t\t// \t\tif (rowStepsIntoVisibleAreaBottom) {\n\t\t\t// \t\t\treturn {\n\t\t\t// \t\t\t\tlastShownItemIndex: currentRowFirstItemIndex + columnsCount - 1\n\t\t\t// \t\t\t}\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// }\n\n\t\t\tif (findFirstShownItemIndex) {\n\t\t\t\tif (rowStepsIntoVisibleAreaTop) {\n\t\t\t\t\t// If item is the first one visible in the viewport\n\t\t\t\t\t// then start showing items from this row.\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfirstShownItemIndex: currentRowFirstItemIndex,\n\t\t\t\t\t\tbeforeItemsHeight\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (findLastShownItemIndex) {\n\t\t\t\tif (rowStepsOutOfVisibleAreaBottomOrIsAtTheBorder) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tlastShownItemIndex: Math.min(\n\t\t\t\t\t\t\t// The index of the last item in the current row.\n\t\t\t\t\t\t\tcurrentRowFirstItemIndex + columnsCount - 1,\n\t\t\t\t\t\t\t// Guards against index overflow.\n\t\t\t\t\t\t\titemsCount - 1\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbeforeItemsHeight += currentRowHeight + verticalSpacingAfterCurrentRow\n\n\t\t\t// if (backwards) {\n\t\t\t// \t// Set `i` to be the first item of the current row.\n\t\t\t// \ti -= columnsCount\n\t\t\t// \tconst prevoiusRowIsBeforeResize = i - 1 < this.getBeforeResizeItemsCount()\n\t\t\t// \tconst previousRowColumnsCount = prevoiusRowIsBeforeResize ? this.getColumnsCountBeforeResize() : this.getColumnsCount()\n\t\t\t// \t// Set `i` to be the first item of the previous row.\n\t\t\t// \ti -= previousRowColumnsCount\n\t\t\t// }\n\t\t}\n\n\t\t// if (backwards) {\n\t\t// \tif (findFirstShownItemIndex) {\n\t\t// \t\twarn('The list is supposed to be visible but no visible item has been found (while traversing backwards)')\n\t\t// \t\treturn null\n\t\t// \t} else if (findLastShownItemIndex) {\n\t\t// \t\treturn {\n\t\t// \t\t\tfirstShownItemIndex: 0\n\t\t// \t\t}\n\t\t// \t}\n\t\t// }\n\n\t\tif (beforeResize) {\n\t\t\treturn {\n\t\t\t\tnotFound: true,\n\t\t\t\tbeforeItemsHeight\n\t\t\t}\n\t\t}\n\n\t\t// This case isn't supposed to happen but it could hypothetically happen\n\t\t// because the list height is measured from the user's screen and\n\t\t// not necessarily can be trusted.\n\t\tif (findFirstShownItemIndex) {\n\t\t\twarn('The list is supposed to be visible but no visible item has been found')\n\t\t\treturn null\n\t\t} else if (findLastShownItemIndex) {\n\t\t\treturn {\n\t\t\t\tlastShownItemIndex: itemsCount - 1\n\t\t\t}\n\t\t}\n\t}\n\n\tgetNonVisibleListShownItemIndexes() {\n\t\tconst layout = {\n\t\t\tfirstShownItemIndex: 0,\n\t\t\tlastShownItemIndex: 0\n\t\t}\n\t\tif (this.getItemHeight(0) === undefined) {\n\t\t\tlayout.firstNonMeasuredItemIndex = 0\n\t\t}\n\t\treturn layout\n\t}\n\n\t/**\n\t * Measures \"before\" items height.\n\t * @param  {number} beforeItemsCount — Basically, first shown item index.\n\t * @return {number}\n\t */\n\tgetBeforeItemsHeight(\n\t\tbeforeItemsCount,\n\t\t{ beforeResize } = {}\n\t) {\n\t\t// This function could potentially also use `this.getPreviouslyCalculatedLayout()`\n\t\t// in order to skip calculating visible item indexes from scratch\n\t\t// and instead just calculate the difference from a \"previously calculated layout\".\n\t\t//\n\t\t// I did a simple test in a web browser and found out that running the following\n\t\t// piece of code is less than 10 milliseconds:\n\t\t//\n\t\t// var startedAt = Date.now()\n\t\t// var i = 0\n\t\t// while (i < 1000000) {\n\t\t//   i++\n\t\t// }\n\t\t// console.log(Date.now() - startedAt)\n\t\t//\n\t\t// Which becomes negligible in my project's use case (a couple thousands items max).\n\n\t\tlet beforeItemsHeight = 0\n\t\tlet i = 0\n\n\t\tif (!beforeResize) {\n\t\t\tconst beforeResizeItemsCount = this.getBeforeResizeItemsCount()\n\n\t\t\tif (beforeResizeItemsCount > 0) {\n\t\t\t\t// First add all \"before resize\" item heights.\n\t\t\t\tbeforeItemsHeight = this.getBeforeItemsHeight(\n\t\t\t\t\t// `firstShownItemIndex` (called `beforeItemsCount`) could be greater than\n\t\t\t\t\t// `beforeResizeItemsCount` when the user scrolls down.\n\t\t\t\t\t// `firstShownItemIndex` (called `beforeItemsCount`) could be less than\n\t\t\t\t\t// `beforeResizeItemsCount` when the user scrolls up.\n\t\t\t\t\tMath.min(beforeItemsCount, beforeResizeItemsCount),\n\t\t\t\t\t{ beforeResize: true }\n\t\t\t\t)\n\t\t\t\ti = beforeResizeItemsCount\n\t\t\t}\n\t\t}\n\n\t\tconst columnsCount = beforeResize ? this.getColumnsCountBeforeResize() : this.getColumnsCount()\n\t\tconst verticalSpacing = beforeResize ? this.getVerticalSpacingBeforeResize() : this.getVerticalSpacing()\n\n\t\twhile (i < beforeItemsCount) {\n\t\t\tconst currentRowFirstItemIndex = i\n\n\t\t\tlet rowHeight = 0\n\t\t\tlet columnIndex = 0\n\t\t\t// Not checking for `itemsCount` overflow here because `i = beforeItemsCount`\n\t\t\t// can only start at the start of a row, meaning that when calculating\n\t\t\t// \"before items height\" it's not supposed to add item heights from the\n\t\t\t// last row of items because in that case it would have to iterate from\n\t\t\t// `i === beforeItemsCount` and that condition is already checked above.\n\t\t\t// while (i < itemsCount) {\n\t\t\twhile (columnIndex < columnsCount) {\n\t\t\t\tlet itemHeight = beforeResize ? this.getItemHeightBeforeResize(i) : this.getItemHeight(i)\n\t\t\t\tif (itemHeight === undefined) {\n\t\t\t\t\t// `itemHeight` can only be `undefined` when not `beforeResize`.\n\t\t\t\t\t// Use the current \"average item height\" as a substitute.\n\t\t\t\t\titemHeight = this.getAverageItemHeight()\n\t\t\t\t}\n\t\t\t\trowHeight = Math.max(rowHeight, itemHeight)\n\t\t\t\ti++\n\t\t\t\tcolumnIndex++\n\t\t\t}\n\n\t\t\tbeforeItemsHeight += rowHeight\n\t\t\tbeforeItemsHeight += verticalSpacing\n\t\t}\n\n\t\treturn beforeItemsHeight\n\t}\n\n\t/**\n\t * Measures \"after\" items height.\n\t * @param  {number} lastShownItemIndex — Last shown item index.\n\t * @param  {number} itemsCount — Items count.\n\t * @return {number}\n\t */\n\tgetAfterItemsHeight(\n\t\tlastShownItemIndex,\n\t\titemsCount\n\t) {\n\t\t// This function could potentially also use `this.getPreviouslyCalculatedLayout()`\n\t\t// in order to skip calculating visible item indexes from scratch\n\t\t// and instead just calculate the difference from a \"previously calculated layout\".\n\t\t//\n\t\t// I did a simple test in a web browser and found out that running the following\n\t\t// piece of code is less than 10 milliseconds:\n\t\t//\n\t\t// var startedAt = Date.now()\n\t\t// var i = 0\n\t\t// while (i < 1000000) {\n\t\t//   i++\n\t\t// }\n\t\t// console.log(Date.now() - startedAt)\n\t\t//\n\t\t// Which becomes negligible in my project's use case (a couple thousands items max).\n\n\t\tconst columnsCount = this.getColumnsCount()\n\t\tconst lastShownRowIndex = Math.floor(lastShownItemIndex / columnsCount)\n\n\t\tlet afterItemsHeight = 0\n\n\t\tlet i = lastShownItemIndex + 1\n\t\twhile (i < itemsCount) {\n\t\t\tlet rowHeight = 0\n\t\t\tlet columnIndex = 0\n\t\t\twhile (columnIndex < columnsCount && i < itemsCount) {\n\t\t\t\tlet itemHeight = this.getItemHeight(i)\n\t\t\t\tif (itemHeight === undefined) {\n\t\t\t\t\titemHeight = this.getAverageItemHeight()\n\t\t\t\t}\n\t\t\t\trowHeight = Math.max(rowHeight, itemHeight)\n\t\t\t\ti++\n\t\t\t\tcolumnIndex++\n\t\t\t}\n\n\t\t\t// Add all \"after\" items height.\n\t\t\tafterItemsHeight += this.getVerticalSpacing()\n\t\t\tafterItemsHeight += rowHeight\n\t\t}\n\n\t\treturn afterItemsHeight\n\t}\n\n\t/**\n\t * Returns the items's top offset relative to the top edge of the first item.\n\t * @param {number} i — Item index\n\t * @return {[number]} Returns `undefined` if any of the previous items haven't been rendered yet.\n\t */\n\tgetItemTopOffset(i) {\n\t\tlet topOffsetInsideScrollableContainer = 0\n\n\t\tconst beforeResizeItemsCount = this.getBeforeResizeItemsCount()\n\t\tconst beforeResizeRowsCount = beforeResizeItemsCount === 0\n\t\t\t? 0\n\t\t\t: Math.ceil(beforeResizeItemsCount / this.getColumnsCountBeforeResize())\n\n\t\tconst maxBeforeResizeRowsCount = i < beforeResizeItemsCount\n\t\t\t? Math.floor(i / this.getColumnsCountBeforeResize())\n\t\t\t: beforeResizeRowsCount\n\n\t\tlet beforeResizeRowIndex = 0\n\t\twhile (beforeResizeRowIndex < maxBeforeResizeRowsCount) {\n\t\t\tconst rowHeight = this.getItemHeightBeforeResize(\n\t\t\t\tbeforeResizeRowIndex * this.getColumnsCountBeforeResize()\n\t\t\t)\n\n\t\t\ttopOffsetInsideScrollableContainer += rowHeight\n\t\t\ttopOffsetInsideScrollableContainer += this.getVerticalSpacingBeforeResize()\n\n\t\t\tbeforeResizeRowIndex++\n\t\t}\n\n\t\tconst itemRowIndex = Math.floor((i - beforeResizeItemsCount) / this.getColumnsCount())\n\n\t\tlet rowIndex = 0\n\t\twhile (rowIndex < itemRowIndex) {\n\t\t\tlet rowHeight = 0\n\t\t\tlet columnIndex = 0\n\t\t\twhile (columnIndex < this.getColumnsCount()) {\n\t\t\t\tconst itemHeight = this.getItemHeight(\n\t\t\t\t\tbeforeResizeItemsCount + rowIndex * this.getColumnsCount() + columnIndex\n\t\t\t\t)\n\t\t\t\tif (itemHeight === undefined) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\trowHeight = Math.max(rowHeight, itemHeight)\n\t\t\t\tcolumnIndex++\n\t\t\t}\n\n\t\t\ttopOffsetInsideScrollableContainer += rowHeight\n\t\t\ttopOffsetInsideScrollableContainer += this.getVerticalSpacing()\n\n\t\t\trowIndex++\n\t\t}\n\n\t\treturn topOffsetInsideScrollableContainer\n\t}\n}\n\nexport const LAYOUT_REASON = {\n\tSCROLL: 'scroll',\n\tSTOPPED_SCROLLING: 'stopped scrolling',\n\tMANUAL: 'manual',\n\tSTARTED: 'started',\n\tNON_MEASURED_ITEMS_HAVE_BEEN_MEASURED: 'non-measured item heights have been measured',\n\tVIEWPORT_WIDTH_CHANGED: 'viewport width changed',\n\tVIEWPORT_HEIGHT_CHANGED: 'viewport height changed',\n\tVIEWPORT_SIZE_UNCHANGED: 'viewport size unchanged',\n\tITEM_HEIGHT_CHANGED: 'item height changed',\n\tITEMS_CHANGED: 'items changed',\n\tTOP_OFFSET_CHANGED: 'list top offset changed'\n}"],"mappings":"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"}