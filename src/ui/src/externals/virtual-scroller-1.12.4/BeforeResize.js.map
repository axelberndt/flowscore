{"version":3,"file":"BeforeResize.js","names":["log","BeforeResize","getState","getVerticalSpacing","getColumnsCount","state","_includesBeforeResizeInState","Boolean","beforeResize","firstShownItemIndex","lastShownItemIndex","itemHeights","length","newlyShownItemRowsHeight","prevFirstReMeasuredItemsRowIndex","Math","floor","newlyShownItemsToIndex","min","i","rowHeight","columnIndex","itemHeight","undefined","getAverageItemHeight","max","cleanedUpBeforeResizeItemRowsHeight","maxParticipatingBeforeResizeItemsCount","participatingBeforeResizeItemRowsCount","ceil","columnsCount","firstCleanedUpBeforeResizeItemsRowIndex","k","verticalSpacing","firstDroppedBeforeResizeItemIndex","lastDroppedBeforeResizeItemIndex","slice","splice","scrollBy","newFirstShownItemIndex","newColumnsCount","prevBeforeResize","prevBeforeResizeItemsCount","prevBeforeResizeBeforeItemsHeight","prevBeforeResizeItemRowsCount","rowIndex","newBeforeResizeAdditionalBeforeItemsHeight","newBeforeResizeBeforeItemsHeight","newBeforeResizeBeforeItemRowsCount","Array","fill","concat","equalizeItemHeights","maxItemsCount","cleanUpBeforeResizeState"],"sources":["../source/BeforeResize.js"],"sourcesContent":["import log from './utility/debug.js'\n\nexport default class BeforeResize {\n\tconstructor({\n\t\tgetState,\n\t\tgetVerticalSpacing,\n\t\tgetColumnsCount\n\t}) {\n\t\tthis.getState = getState\n\t\tthis.getVerticalSpacing = getVerticalSpacing\n\t\tthis.getColumnsCount = getColumnsCount\n\t}\n\n\tinitializeFromState(state) {\n\t\tthis._includesBeforeResizeInState = Boolean(state.beforeResize)\n\t}\n\n\t// Cleans up \"before resize\" item heights and adjusts the scroll position accordingly.\n\t//\n\t// Hypothetically, it could also wait for the user to stop scrolling and only then\n\t// adjust the scroll position. The rationale is that if `window.scrollTo()` is called\n\t// while the user is scrolling, the user would occasionally experience \"lost\" mouse wheel\n\t// events when scrolling with a mouse wheel.\n\t//\n\t// Seems like Twitter's website waits for the user to stop scrolling before applying\n\t// the scroll position correction after a window resize. This library could do that too,\n\t// but that would require rewriting \"before items height\" top padding calculation\n\t// so that it doesn't re-calculate it on every re-render and instead does so incrementally,\n\t// and then, when the user stops, it re-calculates it from scratch removing the error\n\t// and adjusting the scroll position accordingly so that there's no \"jump of content\".\n\t//\n\t// But, seems like it works fine as it is and there's no need to rewrite anything.\n\t//\n\tcleanUpBeforeResizeItemHeights() {\n\t\tconst {\n\t\t\tfirstShownItemIndex,\n\t\t\tlastShownItemIndex,\n\t\t\titemHeights,\n\t\t\tbeforeResize\n\t\t} = this.getState()\n\n\t\t// If there're \"before resize\" properties in `state`\n\t\t// then it means that the corresponding items are waiting to be\n\t\t// re-measured after container resize. Since the resize,\n\t\t// some of those non-re-measured items might have just been measured,\n\t\t// so see if that's true, and if it is, remove those now-obsolete\n\t\t// \"before resize\" item heights and ajust the scroll position\n\t\t// so that there's no \"content jumping\".\n\n\t\tif (beforeResize) {\n\t\t\t// If the user has scrolled up to reveal a previously hidden item\n\t\t\t// that has not yet been re-measured after a previous resize.\n\t\t\tif (firstShownItemIndex < beforeResize.itemHeights.length) {\n\t\t\t\tlog('~ Clean up \"before resize\" item heights and correct scroll position ~')\n\n\t\t\t\t// Some of the \"before\" items have been un-hidden and re-measured.\n\t\t\t\t// Un-hiding those items would result in a \"jump of content\"\n\t\t\t\t// because \"before resize\" heights of those un-hidden items\n\t\t\t\t// could (and most likely will) be different from the current ones,\n\t\t\t\t// or because \"before resize\" columns count is different from\n\t\t\t\t// the current one.\n\t\t\t\t// To prevent a \"jump of content\", calculate the scroll position\n\t\t\t\t// difference and adjust the scroll position.\n\n\t\t\t\t// The height of the item rows that have transitioned\n\t\t\t\t// from hidden to shown.\n\t\t\t\tlet newlyShownItemRowsHeight = 0\n\n\t\t\t\t// Some of the `itemHeights` between the current `firstShownItemIndex` and\n\t\t\t\t// the previous `firstShownItemIndex` could stay `undefined` if the user\n\t\t\t\t// scrolled \"abruptly\": for example, by using a `window.scrollTo()` call.\n\t\t\t\t// In that case, the items below the visible ones won't be rendered and measured.\n\t\t\t\t// In such case, limit the items being iterated over to the current `lastShownItemIndex`\n\t\t\t\t// rather than the previous `firstShownItemIndex`.\n\t\t\t\tconst prevFirstReMeasuredItemsRowIndex = Math.floor(beforeResize.itemHeights.length / this.getColumnsCount())\n\t\t\t\tconst newlyShownItemsToIndex = Math.min(\n\t\t\t\t\tprevFirstReMeasuredItemsRowIndex * this.getColumnsCount() - 1,\n\t\t\t\t\tlastShownItemIndex\n\t\t\t\t)\n\n\t\t\t\tlet i = firstShownItemIndex\n\t\t\t\twhile (i <= newlyShownItemsToIndex) {\n\t\t\t\t\t// Calculate newly shown row height.\n\t\t\t\t\tlet rowHeight = 0\n\t\t\t\t\tlet columnIndex = 0\n\t\t\t\t\twhile (columnIndex < this.getColumnsCount() && i <= newlyShownItemsToIndex) {\n\t\t\t\t\t\tlet itemHeight = itemHeights[i]\n\t\t\t\t\t\tif (itemHeight === undefined) {\n\t\t\t\t\t\t\t// `itemHeight` can only be `undefined` when not `beforeResize`.\n\t\t\t\t\t\t\t// Use the current \"average item height\" as a substitute.\n\t\t\t\t\t\t\titemHeight = this.getAverageItemHeight()\n\t\t\t\t\t\t}\n\t\t\t\t\t\trowHeight = Math.max(rowHeight, itemHeight)\n\t\t\t\t\t\ti++\n\t\t\t\t\t\tcolumnIndex++\n\t\t\t\t\t}\n\t\t\t\t\t// Append to the total \"newly shown item rows height\".\n\t\t\t\t\tnewlyShownItemRowsHeight += rowHeight\n\t\t\t\t\tnewlyShownItemRowsHeight += this.getVerticalSpacing()\n\t\t\t\t}\n\n\t\t\t\t// The height of the \"before resize\" item rows\n\t\t\t\t// that will be \"cleaned up\" in this function call.\n\t\t\t\tlet cleanedUpBeforeResizeItemRowsHeight = 0\n\n\t\t\t\t// Some of the `beforeResize` item rows might have been skipped if the user\n\t\t\t\t// scrolled up \"abruptly\": for example, by using a `window.scrollTo()` call.\n\t\t\t\t// In that case, the \"before resize\" items below the bottom border of the screen\n\t\t\t\t// shouldn't be accounted for when calculating the scrollbar adjustment shift\n\t\t\t\t// because items after `lastShownItemIndex` aren't participating in the calculation\n\t\t\t\t// of `newlyShownItemRowsHeight`.\n\t\t\t\tconst maxParticipatingBeforeResizeItemsCount = Math.min(beforeResize.itemHeights.length, lastShownItemIndex + 1)\n\t\t\t\tconst participatingBeforeResizeItemRowsCount = Math.ceil(maxParticipatingBeforeResizeItemsCount / beforeResize.columnsCount)\n\n\t\t\t\tconst firstCleanedUpBeforeResizeItemsRowIndex = firstShownItemIndex === 0\n\t\t\t\t\t? 0\n\t\t\t\t\t: Math.floor((firstShownItemIndex - 1) / beforeResize.columnsCount) + 1\n\n\t\t\t\tlet k = firstCleanedUpBeforeResizeItemsRowIndex\n\t\t\t\twhile (k < participatingBeforeResizeItemRowsCount) {\n\t\t\t\t\tconst rowHeight = beforeResize.itemHeights[k * beforeResize.columnsCount]\n\t\t\t\t\tcleanedUpBeforeResizeItemRowsHeight += rowHeight\n\t\t\t\t\tcleanedUpBeforeResizeItemRowsHeight += beforeResize.verticalSpacing\n\t\t\t\t\tk++\n\t\t\t\t}\n\n\t\t\t\t// Schedule an asynchronous `this.updateState()` call that will update\n\t\t\t\t// `beforeResize` property of `state`. Ideally, it should be updated\n\t\t\t\t// immediately, but since `this.updateState()` calls are asynchronous,\n\t\t\t\t// the code updates just the underlying `beforeResize.itemHeights`\n\t\t\t\t// array immediately instead, which is still a hack but still a lesser one.\n\t\t\t\tif (firstShownItemIndex === 0) {\n\t\t\t\t\tlog('Drop all \"before resize\" item heights')\n\t\t\t\t} else {\n\t\t\t\t\tconst firstDroppedBeforeResizeItemIndex = firstShownItemIndex\n\t\t\t\t\tconst lastDroppedBeforeResizeItemIndex = beforeResize.itemHeights.length - 1\n\t\t\t\t\tif (firstDroppedBeforeResizeItemIndex === lastDroppedBeforeResizeItemIndex) {\n\t\t\t\t\t\tlog('For item index', firstDroppedBeforeResizeItemIndex, '— drop \"before resize\" height', beforeResize.itemHeights[firstDroppedBeforeResizeItemIndex], )\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlog('For item indexes from', firstDroppedBeforeResizeItemIndex, 'to', lastDroppedBeforeResizeItemIndex, '— drop \"before resize\" heights', beforeResize.itemHeights.slice(firstDroppedBeforeResizeItemIndex))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Immediately update `beforeResize.itemHeights`\n\t\t\t\t// so that the component isn't left in an inconsistent state\n\t\t\t\t// before a `this.updateState()` call below is applied.\n\t\t\t\tbeforeResize.itemHeights.splice(\n\t\t\t\t\tfirstShownItemIndex,\n\t\t\t\t\tbeforeResize.itemHeights.length - firstShownItemIndex\n\t\t\t\t)\n\n\t\t\t\t// Return the \"scroll by\" amount that would correct the scroll position.\n\t\t\t\t// Also return a state update.\n\t\t\t\treturn {\n\t\t\t\t\tscrollBy: newlyShownItemRowsHeight - cleanedUpBeforeResizeItemRowsHeight,\n\t\t\t\t\tbeforeResize: firstShownItemIndex === 0 ? undefined : {\n\t\t\t\t\t\t// Simply change the \"reference\" to `beforeResize` while leaving\n\t\t\t\t\t\t// its contents unchanged. That simply indicates that it has been updated:\n\t\t\t\t\t\t// `beforeResize.itemHeights` array length has been changed \"directly\".\n\t\t\t\t\t\t...beforeResize\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Snapshots \"before resize\" values in order to preserve the currently\n\t// shown items' vertical position on screen so that there's no \"content jumping\".\n\t//\n\t// `newFirstShownItemIndex` is `> 0`.\n\t//\n\tsnapshotBeforeResizeItemHeights({\n\t\tfirstShownItemIndex,\n\t\tnewFirstShownItemIndex,\n\t\tnewColumnsCount\n\t}) {\n\t\tconst columnsCount = this.getColumnsCount()\n\t\tconst verticalSpacing = this.getVerticalSpacing()\n\n\t\tthis._includesBeforeResizeInState = true\n\n\t\tconst {\n\t\t\tbeforeResize: prevBeforeResize,\n\t\t\titemHeights\n\t\t} = this.getState()\n\n\t\tconst prevBeforeResizeItemsCount = prevBeforeResize\n\t\t\t? prevBeforeResize.itemHeights.length\n\t\t\t: 0\n\n\t\t// If there already are \"before resize\" values in `state`\n\t\t// then it means that those should be merged with the new ones.\n\t\t//\n\t\t// `beforeResize.itemHeights` could be empty in an edge case\n\t\t// when there's a pending state update that sets `beforeResize`\n\t\t// to `undefined`, and in that case empty `beforeResize.itemHeights`\n\t\t// signals about that type of a situation.\n\t\t//\n\t\tif (prevBeforeResizeItemsCount > 0) {\n\t\t\t// Because the \"previous\" before resize values might have been captured\n\t\t\t// for a window width corresponding to a layout with a different columns count\n\t\t\t// and different vertical spacing, re-calculate those item heights as if\n\t\t\t// they corresponded to the current columns count and current vertical spacing,\n\t\t\t// since \"previous\" and \"new\" before resize item heights are gonna be merged.\n\t\t\tif (\n\t\t\t\tprevBeforeResize.columnsCount !== columnsCount ||\n\t\t\t\tprevBeforeResize.verticalSpacing !== verticalSpacing\n\t\t\t) {\n\t\t\t\tlet prevBeforeResizeBeforeItemsHeight = 0\n\n\t\t\t\tconst prevBeforeResizeItemRowsCount = Math.ceil(prevBeforeResizeItemsCount / prevBeforeResize.columnsCount)\n\t\t\t\tlet rowIndex = 0\n\t\t\t\twhile (rowIndex < prevBeforeResizeItemRowsCount) {\n\t\t\t\t\t// Since all \"before resize\" item heights are equal within a row,\n\t\t\t\t\t// the height of the first \"before resize\" item in a row is that row's height.\n\t\t\t\t\tconst rowHeight = prevBeforeResize.itemHeights[rowIndex * prevBeforeResize.columnsCount]\n\t\t\t\t\tprevBeforeResizeBeforeItemsHeight += rowHeight\n\t\t\t\t\tprevBeforeResizeBeforeItemsHeight += prevBeforeResize.verticalSpacing\n\t\t\t\t\trowIndex++\n\t\t\t\t}\n\n\t\t\t\tlet newBeforeResizeAdditionalBeforeItemsHeight = 0\n\t\t\t\tlet i = firstShownItemIndex\n\t\t\t\twhile (i < newFirstShownItemIndex) {\n\t\t\t\t\tlet rowHeight = 0\n\t\t\t\t\tlet k = 0\n\t\t\t\t\twhile (k < columnsCount && i < newFirstShownItemIndex) {\n\t\t\t\t\t\trowHeight = Math.max(rowHeight, itemHeights[i])\n\t\t\t\t\t\tk++\n\t\t\t\t\t\ti++\n\t\t\t\t\t}\n\t\t\t\t\tnewBeforeResizeAdditionalBeforeItemsHeight += rowHeight\n\t\t\t\t\tnewBeforeResizeAdditionalBeforeItemsHeight += verticalSpacing\n\t\t\t\t}\n\n\t\t\t\tconst newBeforeResizeBeforeItemsHeight = prevBeforeResizeBeforeItemsHeight + newBeforeResizeAdditionalBeforeItemsHeight\n\t\t\t\tconst newBeforeResizeBeforeItemRowsCount = Math.ceil(newFirstShownItemIndex / columnsCount)\n\n\t\t\t\treturn new Array(newFirstShownItemIndex).fill(\n\t\t\t\t\t// Re-calculate \"before resize\" item heights so that \"previous\" and \"new\" ones\n\t\t\t\t\t// correspond to the same (new) columns count.\n\t\t\t\t\t// Also don't occasionally set item heights to `< 0`.\n\t\t\t\t\tMath.max(0, newBeforeResizeBeforeItemsHeight / newBeforeResizeBeforeItemRowsCount - verticalSpacing)\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\t// Add new item heights to the previously snapshotted ones.\n\t\t\t\treturn prevBeforeResize.itemHeights.concat(\n\t\t\t\t\tequalizeItemHeights(\n\t\t\t\t\t\titemHeights,\n\t\t\t\t\t\tnewFirstShownItemIndex,\n\t\t\t\t\t\tcolumnsCount\n\t\t\t\t\t).slice(prevBeforeResize.itemHeights.length)\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\treturn equalizeItemHeights(\n\t\t\t\titemHeights,\n\t\t\t\tnewFirstShownItemIndex,\n\t\t\t\tcolumnsCount\n\t\t\t)\n\t\t}\n\t}\n\n\tshouldIncludeBeforeResizeValuesInState() {\n\t\treturn this._includesBeforeResizeInState\n\t}\n}\n\n// Equalizes all item heights within a given row, for each row.\n//\n// The reason is that `beforeResize.itemHeights` is not necessarily divisible by\n// `beforeResize.columnsCount`, which would result in varying last row height\n// as items get removed from `beforeResize.itemHeights` as the user scrolls up.\n//\n// By equalizing all item heights within a given row, for each row, such \"jumping\"\n// last \"before resize\" row height is prevented when the user scrolls up.\n//\nfunction equalizeItemHeights(itemHeights, maxItemsCount, columnsCount) {\n\titemHeights = itemHeights.slice(0, Math.ceil(maxItemsCount / columnsCount) * columnsCount)\n\n\tlet rowIndex = 0\n\twhile (rowIndex * columnsCount < maxItemsCount) {\n\t\t// Calculate row height.\n\t\tlet rowHeight = 0\n\t\tlet k = 0\n\t\twhile (k < columnsCount) {\n\t\t\trowHeight = Math.max(rowHeight, itemHeights[rowIndex * columnsCount + k])\n\t\t\tk++\n\t\t}\n\n\t\t// Equalize all item heights within the row.\n\t\tk = 0\n\t\twhile (k < columnsCount) {\n\t\t\titemHeights[rowIndex * columnsCount + k] = rowHeight\n\t\t\tk++\n\t\t}\n\n\t\t// Proceed with the next row.\n\t\trowIndex++\n\t}\n\n\treturn itemHeights.slice(0, maxItemsCount)\n}\n\nexport function cleanUpBeforeResizeState(state) {\n\tif (state.beforeResize) {\n\t\tif (state.beforeResize.itemHeights.length === 0) {\n\t\t\tstate.beforeResize = undefined\n\t\t}\n\t}\n\treturn state\n}"],"mappings":"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"}