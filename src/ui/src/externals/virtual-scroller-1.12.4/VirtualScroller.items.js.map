{"version":3,"file":"VirtualScroller.items.js","names":["log","isDebug","getItemsDiff","fillArray","getItemsCount","getState","items","length","_setItems","newItems","options","previousItems","itemStates","widthHasChanged","stateUpdate","itemHeights","layoutUpdate","itemsUpdateInfo","itemsDiff","firstShownItemIndex","lastShownItemIndex","beforeItemsHeight","afterItemsHeight","shouldRestoreScrollPosition","preserveScrollPositionOnPrependItems","preserveScrollPosition","prependedItemsCount","appendedItemsCount","shouldResetGridLayout","layout","getLayoutUpdateForItemsDiff","itemsCount","columnsCount","getActualColumnsCount","onResetGridLayout","Array","concat","i","getInitialItemState","listHeightMeasurement","snapshotListHeightBeforeAddingNewItems","firstNonMeasuredItemIndex","undefined","getInitialLayoutValues","prepend","append","reset","replace","onBeforeShowItems","newItemsWillBeRendered","count","newState","beforeResize","shouldIncludeBeforeResizeValuesInState","shouldDiscardBeforeResizeItemHeights","_isSettingNewItems","updateState","isItemEqual"],"sources":["../source/VirtualScroller.items.js"],"sourcesContent":["import log, { isDebug } from './utility/debug.js'\nimport getItemsDiff from './getItemsDiff.js'\nimport fillArray from './utility/fillArray.js'\n\nexport default function() {\n\tthis.getItemsCount = () => {\n\t\treturn this.getState().items.length\n\t}\n\n\t/**\n\t * Updates `items`. For example, can prepend or append new items to the list.\n\t * @param  {any[]} newItems\n\t * @param {boolean} [options.preserveScrollPositionOnPrependItems] â€” Set to `true` to enable \"restore scroll position after prepending items\" feature (could be useful when implementing \"Show previous items\" button).\n\t */\n\tthis._setItems = (newItems, options = {}) => {\n\t\tconst {\n\t\t\titems: previousItems\n\t\t} = this.getState()\n\n\t\t// Even if `newItems` are equal to `this.state.items`,\n\t\t// still perform a `updateState()` call, because, if `updateState()` calls\n\t\t// were \"asynchronous\", there could be a situation when a developer\n\t\t// first calls `setItems(newItems)` and then `setItems(oldItems)`:\n\t\t// if this function did `return` `if (newItems === this.state.items)`\n\t\t// then `updateState({ items: newItems })` would be scheduled as part of\n\t\t// `setItems(newItems)` call, but the subsequent `setItems(oldItems)` call\n\t\t// wouldn't do anything resulting in `newItems` being set as a result,\n\t\t// and that wouldn't be what the developer intended.\n\n\t\tlet { itemStates } = this.getState()\n\t\tlet { itemHeights } = this.widthHasChanged\n\t\t\t? this.widthHasChanged.stateUpdate\n\t\t\t: this.getState()\n\n\t\tlog('~ Update items ~')\n\n\t\tlet layoutUpdate\n\t\tlet itemsUpdateInfo\n\n\t\t// Compare the new items to the current items.\n\t\tconst itemsDiff = this.getItemsDiff(previousItems, newItems)\n\n\t\t// See if it's an \"incremental\" items update.\n\t\tif (itemsDiff) {\n\t\t\tconst {\n\t\t\t\tfirstShownItemIndex,\n\t\t\t\tlastShownItemIndex,\n\t\t\t\tbeforeItemsHeight,\n\t\t\t\tafterItemsHeight\n\t\t\t} = this.widthHasChanged\n\t\t\t\t? this.widthHasChanged.stateUpdate\n\t\t\t\t: this.getState()\n\n\t\t\tconst shouldRestoreScrollPosition = firstShownItemIndex === 0 &&\n\t\t\t\t// `preserveScrollPosition` option name is deprecated,\n\t\t\t\t// use `preserveScrollPositionOnPrependItems` instead.\n\t\t\t\t(options.preserveScrollPositionOnPrependItems || options.preserveScrollPosition)\n\n\t\t\tconst {\n\t\t\t\tprependedItemsCount,\n\t\t\t\tappendedItemsCount\n\t\t\t} = itemsDiff\n\n\t\t\tlet shouldResetGridLayout\n\n\t\t\tlayoutUpdate = this.layout.getLayoutUpdateForItemsDiff({\n\t\t\t\tfirstShownItemIndex,\n\t\t\t\tlastShownItemIndex,\n\t\t\t\tbeforeItemsHeight,\n\t\t\t\tafterItemsHeight\n\t\t\t}, {\n\t\t\t\tprependedItemsCount,\n\t\t\t\tappendedItemsCount\n\t\t\t}, {\n\t\t\t\titemsCount: newItems.length,\n\t\t\t\tcolumnsCount: this.getActualColumnsCount(),\n\t\t\t\tshouldRestoreScrollPosition,\n\t\t\t\tonResetGridLayout: () => shouldResetGridLayout = true\n\t\t\t})\n\n\t\t\tif (prependedItemsCount > 0) {\n\t\t\t\tlog('Prepend', prependedItemsCount, 'items')\n\n\t\t\t\titemHeights = new Array(prependedItemsCount).concat(itemHeights)\n\t\t\t\titemStates = fillArray(\n\t\t\t\t\tnew Array(prependedItemsCount),\n\t\t\t\t\t(i) => this.getInitialItemState(newItems[i])\n\t\t\t\t)\n\t\t\t\t\t.concat(itemStates)\n\n\t\t\t\t// Restore scroll position after prepending items (if requested).\n\t\t\t\tif (shouldRestoreScrollPosition) {\n\t\t\t\t\tlog('Will restore scroll position')\n\t\t\t\t\tthis.listHeightMeasurement.snapshotListHeightBeforeAddingNewItems({\n\t\t\t\t\t\tpreviousItems,\n\t\t\t\t\t\tnewItems,\n\t\t\t\t\t\tprependedItemsCount\n\t\t\t\t\t})\n\t\t\t\t\t// \"Seamless prepend\" scenario doesn't result in a re-layout,\n\t\t\t\t\t// so if any \"non measured item\" is currently pending,\n\t\t\t\t\t// it doesn't get reset and will be handled after `state` is updated.\n\t\t\t\t\tif (this.firstNonMeasuredItemIndex !== undefined) {\n\t\t\t\t\t\tthis.firstNonMeasuredItemIndex += prependedItemsCount\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlog('Reset layout')\n\t\t\t\t\tif (shouldResetGridLayout) {\n\t\t\t\t\t\tlog('Reason: Prepended items count', prependedItemsCount, 'is not divisible by Columns Count', this.getActualColumnsCount())\n\t\t\t\t\t\t// Reset item heights because the whole grid is going to be rebalanced\n\t\t\t\t\t\t// and re-rendered in a different configuration.\n\t\t\t\t\t\titemHeights = new Array(newItems.length)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Reset layout because none of the prepended items have been measured.\n\t\t\t\t\t\tlog('Reason: Prepended items\\' heights are unknown')\n\t\t\t\t\t}\n\t\t\t\t\tlayoutUpdate = this.layout.getInitialLayoutValues({\n\t\t\t\t\t\titemsCount: newItems.length,\n\t\t\t\t\t\tcolumnsCount: this.getActualColumnsCount()\n\t\t\t\t\t})\n\t\t\t\t\t// Unschedule a potentially scheduled layout update\n\t\t\t\t\t// after measuring a previously non-measured item\n\t\t\t\t\t// because the list will be re-layout anyway\n\t\t\t\t\t// due to the new items being set.\n\t\t\t\t\tthis.firstNonMeasuredItemIndex = undefined\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (appendedItemsCount > 0) {\n\t\t\t\tlog('Append', appendedItemsCount, 'items')\n\t\t\t\titemHeights = itemHeights.concat(new Array(appendedItemsCount))\n\t\t\t\titemStates = itemStates.concat(\n\t\t\t\t\tfillArray(\n\t\t\t\t\t\tnew Array(appendedItemsCount),\n\t\t\t\t\t\t(i) => this.getInitialItemState(newItems[prependedItemsCount + previousItems.length + i])\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t}\n\n\t\t\titemsUpdateInfo = {\n\t\t\t\tprepend: prependedItemsCount > 0,\n\t\t\t\tappend: appendedItemsCount > 0\n\t\t\t}\n\t\t} else {\n\t\t\tlog('Items have changed, and', (itemsDiff ? 'a re-layout from scratch has been requested.' : 'it\\'s not a simple append and/or prepend.'), 'Rerender the entire list from scratch.')\n\t\t\tlog('Previous items', previousItems)\n\t\t\tlog('New items', newItems)\n\n\t\t\t// Reset item heights and item states.\n\t\t\titemHeights = new Array(newItems.length)\n\t\t\titemStates = fillArray(\n\t\t\t\tnew Array(newItems.length),\n\t\t\t\t(i) => this.getInitialItemState(newItems[i])\n\t\t\t)\n\n\t\t\tlayoutUpdate = this.layout.getInitialLayoutValues({\n\t\t\t\titemsCount: newItems.length,\n\t\t\t\tcolumnsCount: this.getActualColumnsCount()\n\t\t\t})\n\n\t\t\t// Unschedule a potentially scheduled layout update\n\t\t\t// after measuring a previously non-measured item\n\t\t\t// because the list will be re-layout from scratch\n\t\t\t// due to the new items being set.\n\t\t\tthis.firstNonMeasuredItemIndex = undefined\n\n\t\t\t// Also reset any potential pending scroll position restoration.\n\t\t\t// For example, imagine a developer first called `.setItems(incrementalItemsUpdate)`\n\t\t\t// and then called `.setItems(differentItems)` and there was no state update\n\t\t\t// in between those two calls. This could happen because state updates aren't\n\t\t\t// required to be \"synchronous\". On other words, calling `this.updateState()`\n\t\t\t// doesn't necessarily mean that the state is applied immediately.\n\t\t\t// Imagine also that such \"delayed\" state updates could be batched,\n\t\t\t// like they do in React inside event handlers (though that doesn't apply to this case):\n\t\t\t// https://github.com/facebook/react/issues/10231#issuecomment-316644950\n\t\t\t// If `this.listHeightMeasurement` wasn't reset on `.setItems(differentItems)`\n\t\t\t// and if the second `this.updateState()` call overwrites the first one\n\t\t\t// then it would attempt to restore scroll position in a situation when\n\t\t\t// it should no longer do that. Hence the reset here.\n\t\t\tthis.listHeightMeasurement.reset()\n\n\t\t\titemsUpdateInfo = {\n\t\t\t\treplace: true\n\t\t\t}\n\t\t}\n\n\t\tlog('~ Update state ~')\n\n\t\t// const layoutValuesAfterUpdate = {\n\t\t// \t...this.getState(),\n\t\t// \t...layoutUpdate\n\t\t// }\n\n\t\t// `layoutUpdate` is equivalent to `layoutValuesAfterUpdate` because\n\t\t// `layoutUpdate` contains all the relevant properties.\n\t\tlog('First shown item index', layoutUpdate.firstShownItemIndex)\n\t\tlog('Last shown item index', layoutUpdate.lastShownItemIndex)\n\t\tlog('Before items height', layoutUpdate.beforeItemsHeight)\n\t\tlog('After items height (actual or estimated)', layoutUpdate.afterItemsHeight)\n\n\t\t// Optionally preload items to be rendered.\n\t\t//\n\t\t// `layoutUpdate` is equivalent to `layoutValuesAfterUpdate` because\n\t\t// `layoutUpdate` contains all the relevant properties.\n\t\t//\n\t\tthis.onBeforeShowItems(\n\t\t\tnewItems,\n\t\t\titemHeights,\n\t\t\tlayoutUpdate.firstShownItemIndex,\n\t\t\tlayoutUpdate.lastShownItemIndex\n\t\t)\n\n\t\t// `this.newItemsWillBeRendered` signals that new `items` are being rendered,\n\t\t// and that `VirtualScroller` should temporarily stop all other updates.\n\t\t//\n\t\t// `this.newItemsWillBeRendered` is cleared in `onRender()`.\n\t\t//\n\t\t// The values in `this.newItemsWillBeRendered` are used, for example,\n\t\t// in `.onContainerResize()` handler in order to not break state consistency when\n\t\t// state updates are \"asynchronous\" (delayed) and there's a window resize event\n\t\t// in between calling `updateState()` below and that call actually being applied.\n\t\t//\n\t\tthis.newItemsWillBeRendered = {\n\t\t\t...itemsUpdateInfo,\n\t\t\tcount: newItems.length,\n\t\t\t// `layoutUpdate` now contains all layout-related properties, even if those that\n\t\t\t// didn't change. So `firstShownItemIndex` is always in `this.newItemsWillBeRendered`.\n\t\t\tlayout: layoutUpdate\n\t\t}\n\n\t\t// `layoutUpdate` now contains all layout-related properties, even if those that\n\t\t// didn't change. So this part is no longer relevant.\n\t\t//\n\t\t// // If `firstShownItemIndex` is gonna be modified as a result of setting new items\n\t\t// // then keep that \"new\" `firstShownItemIndex` in order for it to be used by\n\t\t// // `onResize()` handler when it calculates \"new\" `firstShownItemIndex`\n\t\t// // based on the new columns count (corresponding to the new window width).\n\t\t// if (layoutUpdate.firstShownItemIndex !== undefined) {\n\t\t// \tthis.newItemsWillBeRendered = {\n\t\t// \t\t...this.newItemsWillBeRendered,\n\t\t// \t\tfirstShownItemIndex: layoutUpdate.firstShownItemIndex\n\t\t// \t}\n\t\t// }\n\n\t\t// Update `VirtualScroller` state.\n\t\t//\n\t\t// This state update should overwrite all the `state` properties\n\t\t// that are also updated in the \"on scroll\" handler (`getShownItemIndexes()`):\n\t\t//\n\t\t// * `firstShownItemIndex`\n\t\t// * `lastShownItemIndex`\n\t\t// * `beforeItemsHeight`\n\t\t// * `afterItemsHeight`\n\t\t//\n\t\t// That's because this `updateState()` update has a higher priority\n\t\t// than that of the \"on scroll\" handler, so it should overwrite\n\t\t// any potential state changes dispatched by the \"on scroll\" handler.\n\t\t//\n\t\tconst newState = {\n\t\t\t...layoutUpdate,\n\t\t\titems: newItems,\n\t\t\titemStates,\n\t\t\titemHeights\n\t\t}\n\n\t\t// Introduced `shouldIncludeBeforeResizeValuesInState()` getter just to prevent\n\t\t// cluttering `state` with `beforeResize: undefined` property if `beforeResize`\n\t\t// hasn't ever been set in `state` previously.\n\t\tif (this.beforeResize.shouldIncludeBeforeResizeValuesInState()) {\n\t\t\tif (this.shouldDiscardBeforeResizeItemHeights()) {\n\t\t\t\t// Reset \"before resize\" item heights because now there're new items prepended\n\t\t\t\t// with unknown heights, or completely new items with unknown heights, so\n\t\t\t\t// `beforeItemsHeight` value won't be preserved anyway.\n\t\t\t\tnewState.beforeResize = undefined\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Overwrite `beforeResize` property in `state` even if it wasn't modified\n\t\t\t\t// because state updates could be \"asynchronous\" and in that case there could be\n\t\t\t\t// some previous `updateState()` call from some previous `setItems()` call that\n\t\t\t\t// hasn't yet been applied, and that previous call might have scheduled setting\n\t\t\t\t// `state.beforeResize` property to `undefined` in order to reset it, but this\n\t\t\t\t// next `updateState()` call might not require resetting `state.beforeResize` property\n\t\t\t\t// so it should undo resetting it by simply overwriting it with its normal value.\n\t\t\t\tnewState.beforeResize = this.widthHasChanged\n\t\t\t\t\t? this.widthHasChanged.stateUpdate.beforeResize\n\t\t\t\t\t: this.getState().beforeResize\n\t\t\t}\n\t\t}\n\n\t\t// `newState` should also overwrite all `state` properties that're updated in `onResize()`\n\t\t// because `setItems()`'s state updates always overwrite `onResize()`'s state updates.\n\t\t// (The least-priority ones are `onScroll()` state updates, but those're simply skipped\n\t\t// if there's a pending `setItems()` or `onResize()` update).\n\t\t//\n\t\t// `state` property exceptions:\n\t\t//\n\t\t// `verticalSpacing` property is not updated here because it's fine setting it to\n\t\t// `undefined` in `onResize()` â€”Â it will simply be re-measured after the component re-renders.\n\t\t//\n\t\t// `columnsCount` property is also not updated here because by definition it's only\n\t\t// updated in `onResize()`.\n\n\t\t// Render.\n\t\tthis._isSettingNewItems = true\n\t\tthis.updateState(newState)\n\t}\n\n\tthis.getItemsDiff = (previousItems, newItems) => {\n\t\treturn getItemsDiff(previousItems, newItems, this.isItemEqual)\n\t}\n}"],"mappings":"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"}