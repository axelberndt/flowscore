{"version":3,"file":"ItemHeights.js","names":["log","warn","isDebug","reportError","ItemHeights","container","itemHeights","getItemHeight","setItemHeight","_get","_set","reset","measuredItemsHeight","firstMeasuredItemIndex","undefined","lastMeasuredItemIndex","i","length","firstShownItemIndex","getNthRenderedItemHeight","lastShownItemIndex","nonPreviouslyMeasuredItemIndexes","previousFirstMeasuredItemIndex","previousLastMeasuredItemIndex","firstMeasuredItemIndexHasBeenUpdated","push","height","_measureItemHeight","previousHeight","count"],"sources":["../source/ItemHeights.js"],"sourcesContent":["import log, { warn, isDebug, reportError } from './utility/debug.js'\n\nexport default class ItemHeights {\n\tconstructor({\n\t\tcontainer,\n\t\titemHeights,\n\t\tgetItemHeight,\n\t\tsetItemHeight\n\t}) {\n\t\tthis.container = container\n\t\tthis._get = getItemHeight\n\t\tthis._set = setItemHeight\n\t\tthis.reset()\n\t}\n\n\treset() {\n\t\tthis.measuredItemsHeight = 0\n\t\t// \"First measured item index\" variable was introduced\n\t\t// because it's not always `0`: when `virtualScroller.setItems()`\n\t\t// is called, some items might get prepended, in which case\n\t\t// `this.lastMeasuredItemIndex` is updated. If there was no\n\t\t// `this.firstMeasuredItemIndex`, then the average item height\n\t\t// calculated in `.getAverage()` would be incorrect in the timeframe\n\t\t// between `.setItems()` is called and those changes have been rendered.\n\t\t// And in that timeframe, `.getAverage()` is used to calculate the \"layout\":\n\t\t// stuff like \"before/after items height\" and \"estimated items count on screen\".\n\t\tthis.firstMeasuredItemIndex = undefined\n\t\tthis.lastMeasuredItemIndex = undefined\n\t}\n\n\t/**\n\t * Can only be called after a `.reset()` (including new instance creation).\n\t * Initializes `this.measuredItemsHeight`, `this.firstMeasuredItemIndex`\n\t * and `this.lastMeasuredItemIndex` instance variables from `VirtualScroller` `state`.\n\t * These instance variables are used when calculating \"average\" item height:\n\t * the \"average\" item height is simply `this.measuredItemsHeight` divided by\n\t * `this.lastMeasuredItemIndex` minus `this.firstMeasuredItemIndex` plus 1.\n\t */\n\treadItemHeightsFromState({ itemHeights }) {\n\t\tlet i = 0\n\t\twhile (i < itemHeights.length) {\n\t\t\tif (itemHeights[i] === undefined) {\n\t\t\t\tif (this.firstMeasuredItemIndex !== undefined) {\n\t\t\t\t\tthis.lastMeasuredItemIndex = i - 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this.firstMeasuredItemIndex === undefined) {\n\t\t\t\t\tthis.firstMeasuredItemIndex = i\n\t\t\t\t}\n\t\t\t\tthis.measuredItemsHeight += itemHeights[i]\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n\n\t// Seems to be no longer used.\n\t// getItemHeight(i, firstShownItemIndex) {\n\t// \tif (this._get(i)) {\n\t// \t\treturn this._get(i)\n\t// \t}\n\t// \tconst itemHeight = this._measureItemHeight(i, firstShownItemIndex)\n\t// \tif (itemHeight) {\n\t// \t\tthis._set(i, itemHeight)\n\t// \t\treturn itemHeight\n\t// \t}\n\t// \treturn this.getAverage()\n\t// }\n\n\t_measureItemHeight(i, firstShownItemIndex) {\n\t\treturn this.container.getNthRenderedItemHeight(i - firstShownItemIndex)\n\t}\n\n\t/**\n\t * Measures item heights:\n\t *\n\t * * For the items that haven't been previously measured,\n\t *   measures them for the first time.\n\t *\n\t * * For the items that have been previoulsy measured,\n\t *   validate that their previously measured height\n\t *   is still equal to their current height.\n\t *   The unequalness may not necessarily be caused by\n\t *   incorrect use of `virtual-scroller`: there are\n\t *   also some valid use cases when such unequalness\n\t *   could happen (see the comments in the code).\n\t *\n\t * @param {number} firstShownItemIndex\n\t * @param {number} lastShownItemIndex\n\t * @return {number[]} The indexes of the items that have not previously been measured and have been measured now.\n\t */\n\tmeasureItemHeights(firstShownItemIndex, lastShownItemIndex) {\n\t\tlog('~ Measure item heights ~')\n\t\t// If no items are rendered, don't measure anything.\n\t\tif (firstShownItemIndex === undefined) {\n\t\t\treturn\n\t\t}\n\t\t// Reset `this.measuredItemsHeight` if it's not a \"continuous\" measured items list:\n\t\t// if a group of items has been measured previously, and now it has rendered a completely\n\t\t// different group of items, and there's a non-measured \"gap\" between those two groups,\n\t\t// then reset `this.measuredItemsHeight` and \"first measured\"/\"last measured\" item indexes.\n\t\t// For example, this could happen when `.setItems()` prepends a lot of new items.\n\t\tif (this.firstMeasuredItemIndex !== undefined) {\n\t\t\tif (\n\t\t\t\tfirstShownItemIndex > this.lastMeasuredItemIndex + 1 ||\n\t\t\t\tlastShownItemIndex < this.firstMeasuredItemIndex - 1\n\t\t\t) {\n\t\t\t\t// Reset.\n\t\t\t\tlog('Non-measured items gap detected. Reset first and last measured item indexes.')\n\t\t\t\tthis.reset()\n\t\t\t}\n\t\t}\n\t\tconst nonPreviouslyMeasuredItemIndexes = []\n\t\tconst previousFirstMeasuredItemIndex = this.firstMeasuredItemIndex\n\t\tconst previousLastMeasuredItemIndex = this.lastMeasuredItemIndex\n\t\tlet firstMeasuredItemIndexHasBeenUpdated = false\n\t\tlet i = firstShownItemIndex\n\t\twhile (i <= lastShownItemIndex) {\n\t\t\t// Measure item heights that haven't been measured previously.\n\t\t\t// Don't re-measure item heights that have been measured previously.\n\t\t\t// The rationale is that developers are supposed to manually call\n\t\t\t// `.onItemHeightDidChange()` immediately every time an item's height has changed.\n\t\t\t// If developers don't neglect that rule, item heights won't\n\t\t\t// change unexpectedly.\n\t\t\tif (this._get(i) === undefined) {\n\t\t\t\tnonPreviouslyMeasuredItemIndexes.push(i)\n\t\t\t\tconst height = this._measureItemHeight(i, firstShownItemIndex)\n\t\t\t\tlog('Item index', i, 'height', height)\n\t\t\t\tthis._set(i, height)\n\t\t\t\t// Update average item height calculation variables\n\t\t\t\t// related to the previously measured items\n\t\t\t\t// that're above the items currently being shown.\n\t\t\t\t// It is known to be a \"continuous\" measured items list,\n\t\t\t\t// because the code at the start of this function checks that.\n\t\t\t\tif (previousFirstMeasuredItemIndex === undefined || i < previousFirstMeasuredItemIndex) {\n\t\t\t\t\tthis.measuredItemsHeight += height\n\t\t\t\t\t// Update first measured item index.\n\t\t\t\t\tif (!firstMeasuredItemIndexHasBeenUpdated) {\n\t\t\t\t\t\t// log('Set first measured item index', i)\n\t\t\t\t\t\tthis.firstMeasuredItemIndex = i\n\t\t\t\t\t\tfirstMeasuredItemIndexHasBeenUpdated = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Update average item height calculation variables\n\t\t\t\t// related to the previously measured items\n\t\t\t\t// that're below the items currently being shown.\n\t\t\t\t// It is known to be a \"continuous\" measured items list,\n\t\t\t\t// because the code at the start of this function checks that.\n\t\t\t\tif (previousLastMeasuredItemIndex === undefined || i > previousLastMeasuredItemIndex) {\n\t\t\t\t\t// If `previousLastMeasuredItemIndex` is `undefined`\n\t\t\t\t\t// then `previousFirstMeasuredItemIndex` is also `undefined`\n\t\t\t\t\t// which means that the item's `height` has already been added\n\t\t\t\t\t// to `this.measuredItemsHeight` in the code above,\n\t\t\t\t\t// so this condition guards against counting the item's `height`\n\t\t\t\t\t// twice in `this.measuredItemsHeight`.\n\t\t\t\t\tif (previousLastMeasuredItemIndex !== undefined) {\n\t\t\t\t\t\t// Add newly shown item height.\n\t\t\t\t\t\tthis.measuredItemsHeight += height\n\t\t\t\t\t}\n\t\t\t\t\t// Update last measured item index.\n\t\t\t\t\tthis.lastMeasuredItemIndex = i\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Validate that the item's height didn't change since it was last measured.\n\t\t\t\t// If it did, then display a warning and update the item's height\n\t\t\t\t// as an attempt to fix things.\n\t\t\t\t// If an item's height changes unexpectedly then it means that there'll\n\t\t\t\t// likely be \"content jumping\".\n\t\t\t\tconst previousHeight = this._get(i)\n\t\t\t\tconst height = this._measureItemHeight(i, firstShownItemIndex)\n\t\t\t\tif (previousHeight !== height) {\n\t\t\t\t\twarn('Item index', i, 'height changed unexpectedly: it was', previousHeight, 'before, but now it is', height, '. Whenever an item\\'s height changes for whatever reason, a developer must call `onItemHeightDidChange(i)` right after that change. If you are calling `onItemHeightDidChange(i)` correctly, then there\\'re several other possible causes. For example, perhaps you forgot to persist the item\\'s \"state\" by calling `setItemState(i, newState)` when that \"state\" did change, and so the item\\'s \"state\" got lost when the item element was unmounted, which resulted in a different item height when the item was shown again with no previous \"state\". Or perhaps you\\'re running your application in \"devleopment\" mode and `VirtualScroller` has initially rendered the list before your CSS styles or custom fonts have loaded, resulting in different item height measurements \"before\" and \"after\" the page has fully loaded.')\n\t\t\t\t\t// Update the item's height as an attempt to fix things.\n\t\t\t\t\tthis._set(i, height)\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\t// // Update average item height.\n\t\t// this.updateAverageItemHeight()\n\t\treturn nonPreviouslyMeasuredItemIndexes\n\t}\n\n\t/**\n\t * Re-measures item height.\n\t * @param  {number} i â€” Item index.\n\t * @param  {number} firstShownItemIndex\n\t */\n\tremeasureItemHeight(i, firstShownItemIndex) {\n\t\tconst previousHeight = this._get(i)\n\t\tconst height = this._measureItemHeight(i, firstShownItemIndex)\n\t\t// // Because this function is called from `.onItemHeightDidChange()`,\n\t\t// // there're no guarantees in which circumstances a developer calls it,\n\t\t// // and for which item indexes.\n\t\t// // Therefore, to guard against cases of incorrect usage,\n\t\t// // this function won't crash anything if the item isn't rendered\n\t\t// // or hasn't been previously rendered.\n\t\t// if (height !== undefined) {\n\t\t// \treportError(`\"onItemHeightDidChange()\" has been called for item ${i}, but that item isn't currently rendered.`)\n\t\t// \treturn\n\t\t// }\n\t\t// if (previousHeight === undefined) {\n\t\t// \treportError(`\"onItemHeightDidChange()\" has been called for item ${i}, but that item hasn't been rendered before.`)\n\t\t// \treturn\n\t\t// }\n\t\tthis._set(i, height)\n\t\tthis.measuredItemsHeight += height - previousHeight\n\t\treturn height\n\t}\n\n\t// /**\n\t//  * \"Average\" item height is stored as an instance variable.\n\t//  * For example, for caching, so that it isn't calculated every time it's requested.\n\t//  * But that would be negligible performance gain, not really worth the extra code.\n\t//  * Another thing it's stored for as an instance variable is\n\t//  * keeping \"previous\" \"average\" item height, because it can be more precise\n\t//  * than the newly calculated \"average\" item height, provided it had\n\t//  * more \"samples\" (measured items). The newly calculated average item height\n\t//  * could get less samples in a scenario when the scroll somehow jumps\n\t//  * from one position to some other distant position: in that case previous\n\t//  * \"total measured items height\" is discarded and the new one is initialized.\n\t//  * Could such situation happen in real life? I guess, it's unlikely.\n\t//  * So I'm commenting out this code, but still keeping it just in case.\n\t//  */\n\t// updateAverageItemHeight() {\n\t// \tthis.averageItemHeightSamplesCount = this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1\n\t// \tthis.averageItemHeight = this.measuredItemsHeight / this.averageItemHeightSamplesCount\n\t// }\n\t//\n\t// /**\n\t//  * Public API: is called by `VirtualScroller`.\n\t//  * @return {number}\n\t//  */\n\t// getAverage() {\n\t// \t// Previously measured average item height might still be\n\t// \t// more precise if it contains more measured items (\"samples\").\n\t// \tif (this.previousAverageItemHeight) {\n\t// \t\tif (this.previousAverageItemHeightSamplesCount > this.averageItemHeightSamplesCount) {\n\t// \t\t\treturn this.previousAverageItemHeight\n\t// \t\t}\n\t// \t}\n\t// \treturn this.averageItemHeight || 0\n\t// }\n\n\t/**\n\t * Public API: is called by `VirtualScroller`.\n\t * @return {number}\n\t */\n\tgetAverage() {\n\t\tif (this.lastMeasuredItemIndex === undefined) {\n\t\t\treturn 0\n\t\t}\n\t\treturn this.measuredItemsHeight / (this.lastMeasuredItemIndex - this.firstMeasuredItemIndex + 1)\n\t}\n\n\tonPrepend(count) {\n\t\tif (this.firstMeasuredItemIndex !== undefined) {\n\t\t\tthis.firstMeasuredItemIndex += count\n\t\t\tthis.lastMeasuredItemIndex += count\n\t\t}\n\t}\n}"],"mappings":"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"}