{"version":3,"file":"Scroll.js","names":["setTimeout","clearTimeout","log","Scroll","bypass","scrollableContainer","itemsContainer","onScroll","initialScrollPosition","onScrollPositionChange","isImmediateLayoutScheduled","hasNonRenderedItemsAtTheTop","hasNonRenderedItemsAtTheBottom","getLatestLayoutVisibleArea","getListTopOffset","getPrerenderMargin","onScrolledToTop","waitForScrollingToStop","scrollByY","scrollToY","getScrollY","ignoreScrollEvents","cancelOnStopScrollingTimer","forceUpdate","top","getHeight","bottom","shouldCallOnScrollListenerWhenStopsScrolling","watchOnStopScrolling","undefined","stopListeningToScroll","onScrollListener","scrollY","onStopScrollingTimer","delayed","ON_STOP_SCROLLING_INACTIVE_PERIOD"],"sources":["../source/Scroll.js"],"sourcesContent":["// For some weird reason, in Chrome, `setTimeout()` would lag up to a second (or more) behind.\n// Turns out, Chrome developers have deprecated `setTimeout()` API entirely without asking anyone.\n// Replacing `setTimeout()` with `requestAnimationFrame()` can work around that Chrome bug.\n// https://github.com/bvaughn/react-virtualized/issues/722\nimport { setTimeout, clearTimeout } from 'request-animation-frame-timeout'\n\nimport log from './utility/debug.js'\n\nexport default class Scroll {\n\tconstructor({\n\t\tbypass,\n\t\tscrollableContainer,\n\t\titemsContainer,\n\t\tonScroll,\n\t\tinitialScrollPosition,\n\t\tonScrollPositionChange,\n\t\tisImmediateLayoutScheduled,\n\t\thasNonRenderedItemsAtTheTop,\n\t\thasNonRenderedItemsAtTheBottom,\n\t\tgetLatestLayoutVisibleArea,\n\t\tgetListTopOffset,\n\t\tgetPrerenderMargin,\n\t\tonScrolledToTop,\n\t\twaitForScrollingToStop\n\t}) {\n\t\tthis.bypass = bypass\n\t\tthis.scrollableContainer = scrollableContainer\n\t\tthis.itemsContainer = itemsContainer\n\t\tthis.onScroll = onScroll\n\t\tthis.initialScrollPosition = initialScrollPosition\n\t\tthis.onScrollPositionChange = onScrollPositionChange\n\t\tthis.isImmediateLayoutScheduled = isImmediateLayoutScheduled\n\t\tthis.hasNonRenderedItemsAtTheTop = hasNonRenderedItemsAtTheTop\n\t\tthis.hasNonRenderedItemsAtTheBottom = hasNonRenderedItemsAtTheBottom\n\t\tthis.getLatestLayoutVisibleArea = getLatestLayoutVisibleArea\n\t\tthis.getListTopOffset = getListTopOffset\n\t\tthis.getPrerenderMargin = getPrerenderMargin\n\t\tthis.onScrolledToTop = onScrolledToTop\n\t\tthis.waitForScrollingToStop = waitForScrollingToStop\n\t}\n\n\tstart() {\n\t\tif (this.initialScrollPosition !== undefined) {\n\t\t\tthis.scrollToY(this.initialScrollPosition)\n\t\t\t// Don't restore this scroll position on restart.\n\t\t\tthis.initialScrollPosition = undefined\n\t\t}\n\t\tif (this.onScrollPositionChange) {\n\t\t\tthis.onScrollPositionChange(this.getScrollY())\n\t\t}\n\t\tthis.stopListeningToScroll = this.scrollableContainer.onScroll(this.onScrollListener)\n\t}\n\n\tstop() {\n\t\tthis.stopListeningToScroll()\n\t\tthis.stopListeningToScroll = undefined\n\t\t// this.onStopScrollingListener = undefined\n\t\tthis.shouldCallOnScrollListenerWhenStopsScrolling = undefined\n\t\tthis.cancelOnStopScrollingTimer()\n\t}\n\n\tscrollToY(scrollY) {\n\t\tthis.ignoreScrollEvents = true\n\t\tthis.scrollableContainer.scrollToY(scrollY)\n\t\tthis.ignoreScrollEvents = undefined\n\t}\n\n\tscrollByY = (scrollByY) => {\n\t\tthis.scrollToY(this.getScrollY() + scrollByY)\n\t}\n\n\tgetScrollY() {\n\t\treturn this.scrollableContainer.getScrollY()\n\t}\n\n\tcancelOnStopScrollingTimer() {\n\t\tif (this.onStopScrollingTimer) {\n\t\t\tclearTimeout(this.onStopScrollingTimer)\n\t\t\tthis.onStopScrollingTimer = undefined\n\t\t}\n\t}\n\n\tcancelScheduledLayout() {\n\t\t// Cancel a \"re-layout when user stops scrolling\" timer.\n\t\tthis.cancelOnStopScrollingTimer()\n\t}\n\n\tonScrollListener = () => {\n\t\tif (this.onScrollPositionChange) {\n\t\t\tthis.onScrollPositionChange(this.getScrollY())\n\t\t}\n\n\t\t// If the user has scrolled up to the top of the items container.\n\t\t// (this option isn't currently used)\n\t\tif (this.onScrolledToTop) {\n\t\t\tif (this.getScrollY() < this.getListTopOffset()) {\n\t\t\t\tthis.onScrolledToTop()\n\t\t\t}\n\t\t}\n\n\t\tif (this.bypass) {\n\t\t\treturn\n\t\t}\n\n\t\tif (this.ignoreScrollEvents) {\n\t\t\treturn\n\t\t}\n\n\t\t// Prefer not performing a re-layout while the user is scrolling (if possible).\n\t\t// If the user doesn't scroll too far and then stops for a moment,\n\t\t// then a mid-scroll re-layout could be delayed until such a brief stop:\n\t\t// presumably, this results in better (smoother) scrolling performance,\n\t\t// delaying the work to when it doesn't introduce any stutter or \"jank\".\n\n\t\t// Reset `this.onStopScrollingTimer` (will be re-created below).\n\t\tthis.cancelOnStopScrollingTimer()\n\n\t\t// See if the latest \"layout\" (the currently rendered set of items)\n\t\t// is still sufficient in order to show all the items that're\n\t\t// currently inside the viewport. If there're some non-rendered items\n\t\t// that're visible in the current viewport, then those items\n\t\t// should be rendered \"immediately\" rather than waiting until\n\t\t// the user stops scrolling.\n\t\tconst forceUpdate =\n\t\t\t// If the items have been rendered at least once\n\t\t\tthis.getLatestLayoutVisibleArea() && (\n\t\t\t\t(\n\t\t\t\t\t// If the user has scrolled up past the \"prerender margin\"\n\t\t\t\t\t// and there're some non-rendered items at the top,\n\t\t\t\t\t// then force a re-layout.\n\t\t\t\t\t//\n\t\t\t\t\t// (during these calculations we assume that the list's top coordinate\n\t\t\t\t\t//  hasn't changed since previous layout; even if that's not exactly true,\n\t\t\t\t\t//  the items will be re-layout when the user stops scrolling anyway)\n\t\t\t\t\t//\n\t\t\t\t\t(this.getScrollY() < this.getLatestLayoutVisibleArea().top - this.getPrerenderMargin()) &&\n\t\t\t\t\tthis.hasNonRenderedItemsAtTheTop()\n\t\t\t\t)\n\t\t\t\t||\n\t\t\t\t(\n\t\t\t\t\t// If the user has scrolled down past the \"prerender margin\"\n\t\t\t\t\t// and there're any non-rendered items left at the end,\n\t\t\t\t\t// then force a re-layout.\n\t\t\t\t\t//\n\t\t\t\t\t// (during these calculations we assume that the list's top coordinate\n\t\t\t\t\t//  hasn't changed since previous layout; even if that's not exactly true,\n\t\t\t\t\t//  the items will be re-layout when the user stops scrolling anyway)\n\t\t\t\t\t//\n\t\t\t\t\t(this.getScrollY() + this.scrollableContainer.getHeight() > this.getLatestLayoutVisibleArea().bottom + this.getPrerenderMargin()) &&\n\t\t\t\t\tthis.hasNonRenderedItemsAtTheBottom()\n\t\t\t\t)\n\t\t\t)\n\n\t\tif (forceUpdate) {\n\t\t\tlog('The user has scrolled far enough: perform a re-layout')\n\t\t} else {\n\t\t\tlog('The user is scrolling: perform a re-layout when they stop scrolling')\n\t\t}\n\n\t\tif (forceUpdate || this.waitForScrollingToStop === false) {\n\t\t\treturn this.onScroll()\n\t\t}\n\n\t\t// If a re-layout is already scheduled at the next \"frame\",\n\t\t// don't schedule a \"re-layout when user stops scrolling\" timer.\n\t\tif (this.isImmediateLayoutScheduled()) {\n\t\t\treturn\n\t\t}\n\n\t\tthis.shouldCallOnScrollListenerWhenStopsScrolling = true\n\t\tthis.watchOnStopScrolling()\n\t}\n\n\twatchOnStopScrolling() {\n\t\tthis.onStopScrollingTimer = setTimeout(\n\t\t\t() => {\n\t\t\t\tthis.onStopScrollingTimer = undefined\n\n\t\t\t\tif (this.shouldCallOnScrollListenerWhenStopsScrolling) {\n\t\t\t\t\tthis.shouldCallOnScrollListenerWhenStopsScrolling = undefined\n\t\t\t\t\tthis.onScroll({ delayed: true })\n\t\t\t\t}\n\n\t\t\t\t// `onStopScrolling()` feature is not currently used.\n\t\t\t\t// if (this.onStopScrollingListener) {\n\t\t\t\t// \tconst onStopScrollingListener = this.onStopScrollingListener\n\t\t\t\t// \tthis.onStopScrollingListener = undefined\n\t\t\t\t// \t// `onStopScrollingListener()` may hypothetically schedule\n\t\t\t\t// \t// another `onStopScrolling()` listener, so set\n\t\t\t\t// \t// `this.onStopScrollingListener` to `undefined` before\n\t\t\t\t// \t// calling it rather than after.\n\t\t\t\t// \tlog('~ The user has stopped scrolling ~')\n\t\t\t\t// \tonStopScrollingListener()\n\t\t\t\t// }\n\t\t\t},\n\t\t\t// \"scroll\" events are usually dispatched every 16 milliseconds\n\t\t\t// for 60fps refresh rate, so waiting for 100 milliseconds feels\n\t\t\t// reasonable: that would be about 6 frames of inactivity period,\n\t\t\t// which could mean that either the user has stopped scrolling\n\t\t\t// (for a moment) or the browser is lagging and stuttering\n\t\t\t// (skipping frames due to high load).\n\t\t\t// If the user continues scrolling then this timeout is constantly\n\t\t\t// refreshed (cancelled and then re-created).\n\t\t\tON_STOP_SCROLLING_INACTIVE_PERIOD\n\t\t)\n\t}\n\n\t// (this function isn't currently used)\n\t// onStopScrolling(onStopScrollingListener) {\n\t// \tthis.onStopScrollingListener = onStopScrollingListener\n\t// \tif (!this.onStopScrollingTimer) {\n\t// \t\tthis.watchOnStopScrolling()\n\t// \t}\n\t// }\n\n\t/**\n\t * Returns visible area coordinates relative to the scrollable container.\n\t * @return {object} `{ top: number, bottom: number }`\n\t */\n\tgetVisibleAreaBounds() {\n\t\tconst scrollY = this.getScrollY()\n\t\treturn {\n\t\t\t// The first pixel of the screen.\n\t\t\ttop: scrollY,\n\t\t\t// The pixel after the last pixel of the screen.\n\t\t\tbottom: scrollY + this.scrollableContainer.getHeight()\n\t\t}\n\t}\n}\n\nconst ON_STOP_SCROLLING_INACTIVE_PERIOD = 100"],"mappings":"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"}